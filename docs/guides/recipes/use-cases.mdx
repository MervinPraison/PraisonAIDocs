---
title: "Use Cases"
description: "12 real-world implementation patterns for PraisonAI recipes"
icon: "lightbulb"
---

# Recipe Use Cases

This guide covers 12 real-world use cases for PraisonAI recipes, including recommended integration models, implementation steps, and security considerations.

---

## 1. SaaS AI Support Reply Drafts

### What It Is
Automatically generate draft replies for customer support tickets using AI, allowing agents to review and send.

### Recommended Integration Model
**Model 3 (HTTP Sidecar)** or **Model 4 (Remote Runner)**
- HTTP API integrates with existing ticketing systems
- Supports multiple concurrent requests
- Easy to add auth for multi-tenant SaaS

### Implementation

<Steps>
  <Step title="Create Recipe">
    ```yaml
    # support-reply/TEMPLATE.yaml
    schema_version: "1.0"
    name: support-reply-drafter
    description: Generate support reply drafts
    
    requires:
      env: [OPENAI_API_KEY]
    
    config:
      input:
        ticket_id:
          type: string
          required: true
        customer_message:
          type: string
          required: true
        context:
          type: string
          required: false
    ```
  </Step>
  <Step title="Start Server">
    ```bash
    praisonai serve recipe --port 8765 --auth api-key
    ```
  </Step>
  <Step title="Integrate with Ticketing System">
    ```python
    import requests

    def generate_reply_draft(ticket_id, customer_message):
        response = requests.post(
            "http://localhost:8765/v1/recipes/run",
            headers={"X-API-Key": "your-key"},
            json={
                "recipe": "support-reply-drafter",
                "input": {
                    "ticket_id": ticket_id,
                    "customer_message": customer_message
                }
            }
        )
        return response.json()["output"]["draft"]
    ```
  </Step>
</Steps>

### Security Considerations
- **PII**: Customer messages may contain PII; ensure data handling compliance
- **Output review**: Always have human review before sending
- **Rate limiting**: Prevent abuse with request limits

### Example Payload
```json
{
  "recipe": "support-reply-drafter",
  "input": {
    "ticket_id": "T-12345",
    "customer_message": "I can't log into my account",
    "context": "Premium customer, 2 years"
  }
}
```

---

## 2. Meeting Notes â†’ Action Items

### What It Is
Extract action items, decisions, and follow-ups from meeting transcripts or notes.

### Recommended Integration Model
**Model 2 (CLI)** or **Model 5 (Event-Driven)**
- CLI for ad-hoc processing
- Event-driven for automated pipeline from recording service

### Implementation

<Steps>
  <Step title="Process via CLI">
    ```bash
    praisonai recipe run meeting-action-items \
      --input '{"transcript": "...meeting notes..."}' \
      --json
    ```
  </Step>
  <Step title="Automated Pipeline">
    ```python
    # Triggered when new transcript arrives
    from praisonai import recipe

    def process_meeting(transcript_path):
        with open(transcript_path) as f:
            transcript = f.read()
        
        result = recipe.run(
            "meeting-action-items",
            input={"transcript": transcript}
        )
        
        return result.output["action_items"]
    ```
  </Step>
</Steps>

### Security Considerations
- **Confidentiality**: Meeting content may be sensitive
- **Access control**: Restrict who can process which meetings
- **Retention**: Define data retention policies

---

## 3. SQL Analyst Assistant

### What It Is
Natural language to SQL query generation with schema awareness and result explanation.

### Recommended Integration Model
**Model 1 (Embedded SDK)**
- Direct integration with data tools
- Low latency for interactive queries
- Access to database connections

### Implementation

<Steps>
  <Step title="Define Recipe with Schema">
    ```python
    from praisonai import recipe

    result = recipe.run(
        "sql-analyst",
        input={
            "question": "Show me top 10 customers by revenue",
            "schema": {
                "customers": ["id", "name", "email"],
                "orders": ["id", "customer_id", "amount", "date"]
            }
        }
    )

    sql_query = result.output["sql"]
    explanation = result.output["explanation"]
    ```
  </Step>
</Steps>

### Security Considerations
- **SQL injection**: Validate generated queries before execution
- **Data access**: Ensure recipe only sees allowed schemas
- **Audit logging**: Log all generated queries

---

## 4. Code Review Assistant

### What It Is
Automated code review providing feedback on style, bugs, security, and best practices.

### Recommended Integration Model
**Model 6 (Plugin Mode)** or **Model 2 (CLI)**
- IDE plugin for real-time feedback
- CLI for CI/CD integration

### Implementation

<Steps>
  <Step title="CI/CD Integration">
    ```bash
    # In GitHub Actions
    - name: AI Code Review
      run: |
        git diff origin/main...HEAD > changes.diff
        praisonai recipe run code-review \
          --input "{\"diff\": \"$(cat changes.diff)\"}" \
          --json > review.json
    ```
  </Step>
  <Step title="IDE Plugin">
    ```javascript
    // VS Code extension
    vscode.commands.registerCommand('praisonai.review', async () => {
      const code = vscode.window.activeTextEditor.document.getText();
      const result = await invokeRecipe('code-review', { code });
      showReviewPanel(result.output.feedback);
    });
    ```
  </Step>
</Steps>

---

## 5. Marketing Content Generator

### What It Is
Generate marketing copy, social posts, email campaigns, and ad variations.

### Recommended Integration Model
**Model 3 (HTTP Sidecar)**
- Integrates with marketing platforms
- Supports batch generation
- Easy A/B testing

### Implementation

<Steps>
  <Step title="Generate Content">
    ```bash
    praisonai endpoints invoke marketing-content \
      --input-json '{
        "product": "AI Assistant",
        "tone": "professional",
        "channels": ["email", "linkedin", "twitter"]
      }' \
      --json
    ```
  </Step>
</Steps>

### Security Considerations
- **Brand safety**: Review generated content for brand alignment
- **Compliance**: Ensure claims are accurate and compliant

---

## 6. Customer Onboarding Concierge

### What It Is
Interactive AI assistant guiding new customers through setup, configuration, and first steps.

### Recommended Integration Model
**Model 4 (Remote Runner)** with streaming
- Real-time conversational interface
- Multi-tenant support
- Session state management

### Implementation

<Steps>
  <Step title="Stream Responses">
    ```python
    from praisonai import recipe

    for event in recipe.run_stream(
        "onboarding-concierge",
        input={"user_id": "U-123", "step": "initial"},
        session_id="session-abc"
    ):
        if event.event_type == "progress":
            print(event.data["message"])
    ```
  </Step>
</Steps>

---

## 7. Fraud Signal Summarizer

### What It Is
Analyze transaction patterns and summarize potential fraud indicators for human review.

### Recommended Integration Model
**Model 5 (Event-Driven)**
- Process transactions asynchronously
- Handle high volume
- Integrate with alerting systems

### Implementation

<Steps>
  <Step title="Event Handler">
    ```python
    def handle_transaction(transaction):
        result = recipe.run(
            "fraud-analyzer",
            input={
                "transaction_id": transaction["id"],
                "amount": transaction["amount"],
                "patterns": transaction["patterns"]
            }
        )
        
        if result.output["risk_score"] > 0.8:
            send_alert(result.output["summary"])
    ```
  </Step>
</Steps>

### Security Considerations
- **Data sensitivity**: Transaction data is highly sensitive
- **False positives**: Balance detection vs. customer friction
- **Audit trail**: Log all decisions for compliance

---

## 8. Document Ingestion + Q&A

### What It Is
Ingest documents, build knowledge base, and answer questions with citations.

### Recommended Integration Model
**Model 1 (Embedded SDK)** or **Model 3 (HTTP Sidecar)**
- SDK for direct integration with document pipelines
- HTTP for multi-service architecture

### Implementation

<Steps>
  <Step title="Ingest Documents">
    ```python
    result = recipe.run(
        "doc-ingestion",
        input={"documents": ["/path/to/doc1.pdf", "/path/to/doc2.pdf"]}
    )
    knowledge_base_id = result.output["kb_id"]
    ```
  </Step>
  <Step title="Query Knowledge Base">
    ```python
    result = recipe.run(
        "doc-qa",
        input={
            "question": "What is the refund policy?",
            "kb_id": knowledge_base_id
        }
    )
    print(result.output["answer"])
    print(result.output["citations"])
    ```
  </Step>
</Steps>

---

## 9. Sales Call Coaching

### What It Is
Analyze sales call recordings/transcripts and provide coaching feedback.

### Recommended Integration Model
**Model 5 (Event-Driven)**
- Process calls asynchronously after completion
- Integrate with call recording systems
- Batch processing for historical analysis

### Implementation

<Steps>
  <Step title="Process Call">
    ```bash
    praisonai recipe run sales-coach \
      --input '{"transcript": "...", "rep_id": "R-123"}' \
      --json
    ```
  </Step>
</Steps>

---

## 10. Data Migration Assistant

### What It Is
Assist with data transformation, mapping, and validation during migrations.

### Recommended Integration Model
**Model 2 (CLI)**
- Scriptable for migration pipelines
- Batch processing support
- Easy to integrate with ETL tools

### Implementation

<Steps>
  <Step title="Generate Mapping">
    ```bash
    praisonai recipe run data-mapper \
      --input '{
        "source_schema": {...},
        "target_schema": {...},
        "sample_data": [...]
      }' \
      --json > mapping.json
    ```
  </Step>
</Steps>

---

## 11. Multi-Agent Router

### What It Is
Intelligent routing of requests to specialized agents based on intent and context.

### Recommended Integration Model
**Model 1 (Embedded SDK)** or **Model 3 (HTTP Sidecar)**
- Low latency routing decisions
- Access to multiple downstream agents

### Implementation

<Steps>
  <Step title="Router Recipe">
    ```python
    result = recipe.run(
        "agent-router",
        input={
            "user_message": "I need help with billing",
            "available_agents": ["billing", "technical", "sales"]
        }
    )
    
    target_agent = result.output["selected_agent"]
    # Route to target agent
    ```
  </Step>
</Steps>

---

## 12. Localization Pipeline

### What It Is
Translate and localize content while preserving context, tone, and formatting.

### Recommended Integration Model
**Model 5 (Event-Driven)** or **Model 2 (CLI)**
- Batch processing for content updates
- Event-driven for real-time localization

### Implementation

<Steps>
  <Step title="Localize Content">
    ```bash
    praisonai recipe run localization \
      --input '{
        "content": "Welcome to our platform!",
        "source_lang": "en",
        "target_langs": ["es", "fr", "de", "ja"],
        "context": "marketing_homepage"
      }' \
      --json
    ```
  </Step>
</Steps>

### Security Considerations
- **Cultural sensitivity**: Review translations for cultural appropriateness
- **Legal compliance**: Ensure translations meet local regulations

---

## Testing with Real API Keys

For all use cases, test with real API keys:

```bash
# Set API key
export OPENAI_API_KEY=your-key

# Run a test
praisonai recipe run my-recipe \
  --input '{"test": "data"}' \
  --json

# Verify output
echo $?  # Should be 0
```

## Next Steps

- Review [Integration Models](/docs/guides/recipes/integration-models) for detailed setup
- Check [Personas](/docs/guides/recipes/personas) for role-specific guidance
- Explore the [CLI Reference](/docs/cli/recipes) for command details
