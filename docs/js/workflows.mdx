---
title: "Workflows"
sidebarTitle: "Workflows"
description: "Pipeline and orchestration patterns for AI agents"
icon: "diagram-project"
---

PraisonAI TypeScript provides workflow primitives for orchestrating complex agent pipelines.

## Installation

```bash
npm install praisonai
```

## Basic Workflow

```typescript
import { Workflow } from 'praisonai';

const workflow = new Workflow<number, number>('math-pipeline')
  .step('add', async (input) => input + 10)
  .step('multiply', async (input) => input * 2);

const { output, results } = await workflow.run(5);
console.log(output); // 30 = (5 + 10) * 2
```

## Step Configuration

```typescript
const workflow = new Workflow('configured')
  .addStep({
    name: 'fetch-data',
    execute: async (input) => fetchData(input),
    timeout: 5000,
    onError: 'retry',
    maxRetries: 3
  })
  .addStep({
    name: 'process',
    execute: async (data) => processData(data),
    onError: 'skip' // Skip on error, continue pipeline
  });
```

## Conditional Steps

```typescript
const workflow = new Workflow('conditional')
  .step('always-runs', async (input) => input)
  .addStep({
    name: 'conditional-step',
    condition: (context) => context.metadata.shouldRun === true,
    execute: async (input) => expensiveOperation(input)
  })
  .step('final', async (input) => input);
```

## Context Sharing

```typescript
const workflow = new Workflow<string, string>('context-demo')
  .addStep({
    name: 'set-context',
    execute: async (input, context) => {
      context.set('original', input);
      return input.toUpperCase();
    }
  })
  .addStep({
    name: 'use-context',
    execute: async (input, context) => {
      const original = context.metadata.original;
      return `${input} (was: ${original})`;
    }
  });

const { output } = await workflow.run('hello');
// output: "HELLO (was: hello)"
```

## Access Previous Results

```typescript
const workflow = new Workflow<number, number>('result-access')
  .step('first', async (input) => input * 2)
  .addStep({
    name: 'second',
    execute: async (input, context) => {
      const firstResult = context.get<number>('first');
      return input + (firstResult || 0);
    }
  });
```

## Parallel Execution

```typescript
import { parallel } from 'praisonai';

const results = await parallel([
  async () => fetchFromAPI1(),
  async () => fetchFromAPI2(),
  async () => fetchFromAPI3()
]);

// All three run concurrently
console.log(results); // [result1, result2, result3]
```

## Route (Conditional Branching)

```typescript
import { route } from 'praisonai';

const result = await route([
  { 
    condition: () => userType === 'admin', 
    execute: async () => adminWorkflow() 
  },
  { 
    condition: () => userType === 'user', 
    execute: async () => userWorkflow() 
  }
], async () => guestWorkflow()); // Default
```

## Loop (Repeat Until)

```typescript
import { loop } from 'praisonai';

const results = await loop(
  async (iteration) => {
    const result = await checkStatus();
    return result;
  },
  (result, iteration) => result.status !== 'complete' && iteration < 10
);
```

## Repeat (Fixed Iterations)

```typescript
import { repeat } from 'praisonai';

const results = await repeat(
  async (i) => {
    console.log(`Iteration ${i}`);
    return await processItem(i);
  },
  5 // Run 5 times
);
```

## Error Handling

```typescript
const workflow = new Workflow('error-handling')
  .addStep({
    name: 'risky',
    onError: 'fail', // Stop pipeline on error (default)
    execute: async () => riskyOperation()
  });

const { output, results } = await workflow.run(input);

for (const result of results) {
  if (result.status === 'failed') {
    console.error(`Step ${result.stepName} failed:`, result.error);
  }
}
```

## Step Results

```typescript
const { output, results, context } = await workflow.run(input);

for (const result of results) {
  console.log(`${result.stepName}: ${result.status}`);
  console.log(`  Duration: ${result.duration}ms`);
  if (result.output) console.log(`  Output:`, result.output);
}
```
