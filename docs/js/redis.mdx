---
title: "Redis Integration"
description: "Give Agents fast caching, sessions, and real-time messaging with Redis"
icon: "bolt"
---

# Redis for Agents

Redis enables your Agents to cache responses, maintain sessions across requests, and communicate in real-time. This is essential for production Agents that need speed and scalability.

## Agent with Response Caching

Cache expensive Agent responses to reduce latency and API costs:

```typescript
import { Agent, createUpstashRedis } from 'praisonai';

const redis = createUpstashRedis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

const agent = new Agent({
  name: 'Research Assistant',
  instructions: 'Provide detailed research on topics.'
});

// Agent with Redis caching
async function cachedAgentChat(query: string) {
  const cacheKey = `agent:response:${Buffer.from(query).toString('base64')}`;
  
  // Check cache first
  const cached = await redis.get(cacheKey);
  if (cached) {
    console.log('âš¡ Cache hit - instant response');
    return cached;
  }
  
  // Generate new response
  const response = await agent.chat(query);
  
  // Cache for 1 hour
  await redis.set(cacheKey, response, 3600);
  
  return response;
}

// First call: ~2s (API call)
await cachedAgentChat('Explain quantum computing');
// Second call: ~10ms (cached)
await cachedAgentChat('Explain quantum computing');
```

## Agent with Persistent Sessions

Maintain conversation history across server restarts:

```typescript
import { Agent, createUpstashRedis } from 'praisonai';

const redis = createUpstashRedis({ url, token });

const agent = new Agent({
  name: 'Support Agent',
  instructions: 'You are a helpful support agent. Use conversation history for context.'
});

class AgentSessionManager {
  async chat(sessionId: string, message: string) {
    // Load conversation history from Redis
    const historyKey = `session:${sessionId}:history`;
    const history = await redis.get(historyKey) || [];
    
    // Build context from history
    const context = history.map((m: any) => `${m.role}: ${m.content}`).join('\n');
    const prompt = context ? `${context}\nuser: ${message}` : message;
    
    // Get Agent response
    const response = await agent.chat(prompt);
    
    // Save updated history
    history.push({ role: 'user', content: message });
    history.push({ role: 'assistant', content: response });
    await redis.set(historyKey, history, 86400); // 24h TTL
    
    return response;
  }
  
  async getHistory(sessionId: string) {
    return await redis.get(`session:${sessionId}:history`) || [];
  }
  
  async clearSession(sessionId: string) {
    await redis.delete(`session:${sessionId}:history`);
  }
}

const sessions = new AgentSessionManager();

// Conversation persists across requests
await sessions.chat('user-123', 'My order #456 is late');
await sessions.chat('user-123', 'Can you check the status?'); // Agent remembers context
```

## Multi-Agent Communication with Pub/Sub

Agents can communicate in real-time:

```typescript
import { Agent, createMemoryRedis } from 'praisonai';

const redis = createMemoryRedis();

// Agent 1: Monitors for tasks
const workerAgent = new Agent({
  name: 'Worker',
  instructions: 'Process tasks as they arrive.'
});

// Agent 2: Dispatches tasks
const dispatcherAgent = new Agent({
  name: 'Dispatcher',
  instructions: 'Break down requests into tasks.'
});

// Worker subscribes to task channel
await redis.subscribe('agent:tasks', async (message) => {
  const task = JSON.parse(message);
  console.log(`Worker received task: ${task.type}`);
  
  const result = await workerAgent.chat(`Process this task: ${task.description}`);
  
  // Publish result
  await redis.publish('agent:results', JSON.stringify({
    taskId: task.id,
    result
  }));
});

// Dispatcher publishes tasks
async function dispatchWork(request: string) {
  const breakdown = await dispatcherAgent.chat(`Break this into tasks: ${request}`);
  const tasks = JSON.parse(breakdown);
  
  for (const task of tasks) {
    await redis.publish('agent:tasks', JSON.stringify(task));
  }
}
```

## Agent Rate Limiting

Prevent API abuse with Redis-based rate limiting:

```typescript
import { Agent, createUpstashRedis } from 'praisonai';

const redis = createUpstashRedis({ url, token });

const agent = new Agent({
  name: 'API Agent',
  instructions: 'You help with API queries.'
});

async function rateLimitedChat(userId: string, message: string) {
  const rateLimitKey = `ratelimit:${userId}`;
  
  // Check rate limit (10 requests per minute)
  const count = await redis.get(rateLimitKey) || 0;
  if (count >= 10) {
    throw new Error('Rate limit exceeded. Please wait.');
  }
  
  // Increment counter
  await redis.set(rateLimitKey, count + 1, 60); // 60s window
  
  // Process request
  return await agent.chat(message);
}
```

## Agent State Storage

Store Agent state and context:

```typescript
import { Agent, createTool, createUpstashRedis } from 'praisonai';

const redis = createUpstashRedis({ url, token });

// Tool to save Agent memory
const saveMemory = createTool({
  name: 'save_memory',
  description: 'Save important information for later',
  parameters: {
    type: 'object',
    properties: {
      key: { type: 'string', description: 'Memory key' },
      value: { type: 'string', description: 'Information to remember' }
    },
    required: ['key', 'value']
  },
  execute: async ({ key, value }) => {
    await redis.hset('agent:memory', key, value);
    return `Saved: ${key}`;
  }
});

// Tool to recall Agent memory
const recallMemory = createTool({
  name: 'recall_memory',
  description: 'Recall previously saved information',
  parameters: {
    type: 'object',
    properties: {
      key: { type: 'string', description: 'Memory key to recall' }
    },
    required: ['key']
  },
  execute: async ({ key }) => {
    const value = await redis.hget('agent:memory', key);
    return value || 'No memory found for this key';
  }
});

const agent = new Agent({
  name: 'Memory Agent',
  instructions: 'You can save and recall information using your memory tools.',
  tools: [saveMemory, recallMemory]
});

await agent.chat('Remember that the user prefers dark mode');
await agent.chat('What are the user preferences?'); // Agent recalls from Redis
```

## Agent Task Queue

Queue tasks for background processing:

```typescript
import { Agent, createUpstashRedis } from 'praisonai';

const redis = createUpstashRedis({ url, token });

const processingAgent = new Agent({
  name: 'Processor',
  instructions: 'Process documents thoroughly.'
});

// Add task to queue
async function queueTask(task: any) {
  await redis.rpush('agent:queue', task);
  return `Task queued: ${task.id}`;
}

// Process tasks from queue
async function processQueue() {
  while (true) {
    const tasks = await redis.lrange('agent:queue', 0, 0);
    if (tasks.length === 0) break;
    
    const task = tasks[0];
    await redis.lpop('agent:queue');
    
    const result = await processingAgent.chat(`Process: ${JSON.stringify(task)}`);
    await redis.set(`result:${task.id}`, result);
  }
}
```

## Environment Variables

```bash
UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=your-token
```

## Related

- [Sessions](/docs/js/sessions) - Agent session management
- [PostgreSQL](/docs/js/postgres) - Persistent Agent storage
- [Cache](/docs/js/cache) - In-memory caching for Agents
