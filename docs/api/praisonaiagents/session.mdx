---
title: "Session Module"
description: "Documentation for the praisonaiagents.session module - Stateful applications and remote agents"
icon: "circle-nodes"
---

# Module praisonaiagents.session

The session module provides high-level abstractions for building stateful AI applications with persistent memory, knowledge management, and support for both local and remote agent connectivity.

## Classes

### Session
The main class for managing stateful agent sessions with integrated memory and knowledge systems.

#### Parameters
- `session_id: str` - Unique identifier for the session
- `user_id: str = "default"` - User identifier for multi-user support
- `remote_url: Optional[str] = None` - URL for remote agent connectivity
- `api_key: Optional[str] = None` - API key for remote authentication
- `auto_save: bool = True` - Automatically save state changes
- `storage_path: str = ".praison/sessions"` - Base path for session storage
- `memory_config: Optional[Dict[str, Any]] = None` - Memory system configuration
- `knowledge_config: Optional[Dict[str, Any]] = None` - Knowledge system configuration

#### Properties
- `memory` - Lazy-loaded Memory instance
- `knowledge` - Lazy-loaded Knowledge instance
- `session_dir` - Directory path for session data
- `is_remote` - Whether operating in remote mode

#### State Management Methods
- `save_state(data: Dict[str, Any])` - Save arbitrary state data
- `restore_state() â†’ Dict[str, Any]` - Restore saved state
- `get_state(key: str, default=None)` - Get specific state value
- `set_state(key: str, value: Any)` - Set specific state value
- `clear_state()` - Clear all state data

#### Memory Methods
- `store_short_memory(content: str)` - Store in short-term memory
- `store_long_memory(content: str, quality_score: float = 0.7)` - Store in long-term memory
- `search_memory(query: str, memory_type: str = "all", limit: int = 5)` - Search memories
- `get_memory_context(query: str, max_items: int = 3)` - Build context from memory

#### Knowledge Methods
- `add_knowledge(source: str)` - Add knowledge from file or URL
- `search_knowledge(query: str, limit: int = 5)` - Search knowledge base
- `clear_knowledge()` - Clear knowledge base

#### Agent Methods
- `Agent(**kwargs)` - Create agent with session context (recommended)
- `create_agent(**kwargs)` - Legacy method for agent creation
- `test_remote_connection()` - Test remote agent connectivity

## Usage Examples

### Basic Session Management
```python
from praisonaiagents import Session

# Create a new session
session = Session(session_id="customer_support_123")

# Save state
session.save_state({
    "customer_name": "John Doe",
    "ticket_id": "SUP-456",
    "priority": "high"
})

# Retrieve state
state = session.restore_state()
print(f"Handling ticket {state['ticket_id']} for {state['customer_name']}")
```

### Stateful Agent with Memory
```python
# Create session with memory configuration
session = Session(
    session_id="assistant_session",
    memory_config={
        "provider": "rag",
        "use_embedding": True
    }
)

# Create agent with session context
agent = session.Agent(
    name="Personal Assistant",
    role="Helpful AI assistant",
    instructions="Remember user preferences and past conversations"
)

# Memory is automatically managed
response = agent.chat("My favorite color is blue")
session.store_long_memory("User's favorite color: blue", quality_score=0.9)

# Later retrieval
context = session.get_memory_context("What's my favorite color?")
```

### Knowledge-Enhanced Session
```python
# Initialize session with knowledge
session = Session(
    session_id="research_assistant",
    knowledge_config={
        "vector_store": {
            "provider": "chroma",
            "config": {
                "collection_name": "research_docs"
            }
        }
    }
)

# Add knowledge sources
session.add_knowledge("research_paper.pdf")
session.add_knowledge("https://example.com/article")

# Create knowledge-aware agent
agent = session.Agent(
    name="Research Assistant",
    role="Academic researcher",
    instructions="Use the knowledge base to answer questions"
)

# Knowledge is automatically searched during chat
response = agent.chat("What are the key findings?")
```

### Remote Agent Connection
```python
# Connect to remote agent
session = Session(
    session_id="remote_session",
    remote_url="https://api.example.com/agent",
    api_key="your-api-key"
)

# Test connection
if session.test_remote_connection():
    print("Connected to remote agent")
    
    # Remote chat
    response = session.chat("Hello from remote client")
else:
    print("Failed to connect")
```

### Multi-User Sessions
```python
# User-specific session
session = Session(
    session_id="app_main",
    user_id="user_123"
)

# User preferences
session.set_state("theme", "dark")
session.set_state("language", "en")

# User-specific memory
session.store_long_memory(
    "User prefers technical explanations",
    quality_score=0.8
)

# Create personalized agent
agent = session.Agent(
    name="User Assistant",
    instructions=f"User {session.user_id} prefers {session.get_state('theme')} theme"
)
```

### Session Restoration
```python
# Original session
session1 = Session(session_id="project_alpha")
session1.save_state({"progress": 75, "phase": "testing"})
session1.store_long_memory("Completed unit tests successfully")

# Later restoration
session2 = Session(session_id="project_alpha")  # Same ID
state = session2.restore_state()
print(f"Project progress: {state['progress']}%")

# Memory persists
memories = session2.search_memory("unit tests")
```

### State Management Patterns
```python
# Incremental state updates
session = Session(session_id="game_session")

# Initialize state
session.save_state({
    "score": 0,
    "level": 1,
    "inventory": []
})

# Update specific values
session.set_state("score", session.get_state("score", 0) + 10)

# Complex state updates
inventory = session.get_state("inventory", [])
inventory.append("sword")
session.set_state("inventory", inventory)
```

## Configuration

### Memory Configuration
```python
memory_config = {
    "provider": "mem0",  # or "rag", "none"
    "config": {
        "graph_store": {
            "provider": "neo4j",
            "config": {...}
        }
    }
}
```

### Knowledge Configuration
```python
knowledge_config = {
    "vector_store": {
        "provider": "chroma",
        "config": {
            "collection_name": "session_knowledge"
        }
    },
    "chunker": {
        "type": "semantic",
        "chunk_size": 1024
    }
}
```

### Storage Configuration
```python
# Custom storage path
session = Session(
    session_id="my_app",
    storage_path="/var/data/sessions"
)

# Auto-save disabled for manual control
session = Session(
    session_id="manual_session",
    auto_save=False
)
# Manually save when needed
session.save_state(data)
```

## Remote Agent Protocol

### Request Format
```json
{
    "messages": [{"role": "user", "content": "Hello"}],
    "context": {
        "session_id": "session_123",
        "user_id": "user_456"
    }
}
```

### Response Format
```json
{
    "response": "Hello! How can I help you?",
    "session_id": "session_123",
    "metadata": {}
}
```

## Best Practices
1. **Session ID Strategy** - Use meaningful, unique session IDs
2. **State Design** - Keep state data structured and validated
3. **Memory Management** - Regular cleanup of old sessions
4. **Error Handling** - Implement fallbacks for remote failures
5. **Security** - Validate user_id in multi-tenant applications
6. **Performance** - Use lazy loading for memory and knowledge