---
title: "Autonomy"
sidebarTitle: "Autonomy"
description: "Control how independently agents operate - from suggestions to full automation"
icon: "robot"
---

Autonomy controls how independently an agent operates - from requiring approval for every action to fully autonomous execution.

```mermaid
graph LR
    subgraph "Autonomy Levels"
        Suggest[üí¨ Suggest<br/>Ask before acting]
        AutoEdit[‚úèÔ∏è Auto Edit<br/>Edit without asking]
        FullAuto[üöÄ Full Auto<br/>Complete autonomy]
    end
    
    Suggest -->|"More control"| User[üë§ User]
    AutoEdit -->|"Balanced"| User
    FullAuto -->|"Hands-off"| User
    
    classDef suggest fill:#6366F1,stroke:#7C90A0,color:#fff
    classDef auto fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef full fill:#10B981,stroke:#7C90A0,color:#fff
    
    class Suggest suggest
    class AutoEdit auto
    class FullAuto full
```

## Quick Start

<Steps>

<Step title="Enable Autonomy">
```python
from praisonaiagents import Agent

agent = Agent(
    name="Autonomous Agent",
    instructions="You help with coding tasks",
    autonomy=True  # Enable with defaults
)

agent.start("Refactor the authentication module")
```
</Step>

<Step title="With Configuration">
```python
from praisonaiagents import Agent

agent = Agent(
    name="Controlled Agent",
    instructions="You manage files and code",
    autonomy={
        "max_iterations": 30,           # Max iterations
        "doom_loop_threshold": 5,       # Detect stuck loops
        "auto_escalate": True,          # Escalate on failures
    }
)
```
</Step>

</Steps>

---

## Autonomy Stages

The agent automatically selects an execution stage based on task complexity:

```mermaid
graph TB
    subgraph "Stage: DIRECT"
        D1[Simple question] --> D2[Immediate response]
    end
    
    subgraph "Stage: HEURISTIC"
        H1[File references] --> H2[Context-aware response]
    end
    
    subgraph "Stage: PLANNED"
        P1[Edit/test intent] --> P2[Plan then execute]
    end
    
    subgraph "Stage: AUTONOMOUS"
        A1[Multi-step task] --> A2[Full autonomous loop]
    end
    
    classDef direct fill:#10B981,stroke:#7C90A0,color:#fff
    classDef heuristic fill:#189AB4,stroke:#7C90A0,color:#fff
    classDef planned fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef autonomous fill:#6366F1,stroke:#7C90A0,color:#fff
    
    class D1,D2 direct
    class H1,H2 heuristic
    class P1,P2 planned
    class A1,A2 autonomous
```

| Stage | Triggers | Behavior |
|-------|----------|----------|
| `direct` | Simple questions, explanations | Single response |
| `heuristic` | File references, code blocks | Context-aware |
| `planned` | Edit/test intent | Plan before acting |
| `autonomous` | Multi-step, refactoring | Full iteration loop |

---

## Configuration Options

```python
from praisonaiagents import Agent

# Using dict config
agent = Agent(
    instructions="You help with coding tasks",
    autonomy={
        "max_iterations": 30,
        "doom_loop_threshold": 5,
        "auto_escalate": True,
    }
)
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enabled` | `bool` | `True` | Whether autonomy is enabled |
| `max_iterations` | `int` | `20` | Maximum iterations before stopping |
| `doom_loop_threshold` | `int` | `3` | Repeated actions to trigger doom loop |
| `auto_escalate` | `bool` | `True` | Automatically escalate complexity |
| `observe` | `bool` | `False` | Emit observability events |

---

## Doom Loop Detection

Prevents agents from getting stuck in repetitive failure patterns:

```mermaid
sequenceDiagram
    participant Agent
    participant Detector
    participant User
    
    loop Attempt 1-3
        Agent->>Agent: Try action
        Agent->>Detector: Log failure
    end
    
    Detector->>Detector: Detect pattern
    Detector->>Agent: Stop loop
    Agent->>User: Request help
```

```python
agent = Agent(
    instructions="You fix bugs",
    autonomy={
        "doom_loop_threshold": 3,  # Stop after 3 similar failures
    }
)
```

---

## Escalation Pipeline

When an agent can't complete a task, it escalates:

```mermaid
graph LR
    subgraph "Escalation Flow"
        Try[üîÑ Try] -->|Fail| Retry[üîÑ Retry]
        Retry -->|Fail| Escalate[‚¨ÜÔ∏è Escalate]
        Escalate --> Human[üë§ Human]
        Escalate --> Stronger[üß† Stronger Model]
    end
    
    classDef try fill:#10B981,stroke:#7C90A0,color:#fff
    classDef escalate fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef human fill:#6366F1,stroke:#7C90A0,color:#fff
    
    class Try,Retry try
    class Escalate escalate
    class Human,Stronger human
```

```python
agent = Agent(
    instructions="You solve complex problems",
    autonomy={
        "auto_escalate": True,  # Enable escalation
        "max_iterations": 20,   # Max attempts before escalating
    }
)
```

---

## Signal Detection

Autonomy uses heuristics to detect task complexity:

```python
# Signals detected from prompts
SIMPLE_KEYWORDS = {"what is", "explain", "describe"}
COMPLEX_KEYWORDS = {"refactor", "implement", "debug", "fix"}
EDIT_KEYWORDS = {"edit", "modify", "change", "update"}
```

```mermaid
graph TB
    Prompt[üìù Prompt] --> Analyze[üîç Analyze]
    Analyze --> Simple{Simple?}
    Simple -->|Yes| Direct[‚ö° Direct Response]
    Simple -->|No| Complex{Complex?}
    Complex -->|Yes| Plan[üìã Plan First]
    Complex -->|No| Heuristic[üéØ Heuristic]
    
    classDef prompt fill:#6366F1,stroke:#7C90A0,color:#fff
    classDef decision fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef action fill:#10B981,stroke:#7C90A0,color:#fff
    
    class Prompt prompt
    class Simple,Complex decision
    class Direct,Plan,Heuristic,Analyze action
```

---

## Use Cases

<CardGroup cols={2}>
  <Card title="Code Refactoring" icon="code">
    **Best for**: Multi-step code changes
    
    Agent plans, executes, and verifies changes autonomously.
  </Card>
  <Card title="Research Tasks" icon="magnifying-glass">
    **Best for**: Information gathering
    
    Agent searches, synthesizes, and reports findings.
  </Card>
  <Card title="Bug Fixing" icon="bug">
    **Best for**: Debugging workflows
    
    Agent analyzes, fixes, and tests iteratively.
  </Card>
  <Card title="Content Generation" icon="pen">
    **Best for**: Writing and editing
    
    Agent drafts, refines, and polishes content.
  </Card>
</CardGroup>

---

## Best Practices

<AccordionGroup>
  <Accordion title="Start with lower iteration limits">
    Begin with lower `max_iterations` and increase as needed for complex tasks.
  </Accordion>
  
  <Accordion title="Enable doom loop detection">
    Keep `doom_loop_threshold` low (3-5) to prevent runaway agents and wasted resources.
  </Accordion>
  
  <Accordion title="Use auto_escalate for complex tasks">
    Enable `auto_escalate` to let agents escalate to stronger models when stuck.
  </Accordion>
  
  <Accordion title="Monitor with observe mode">
    Set `observe=True` during development to track agent behavior.
  </Accordion>
</AccordionGroup>

---

## Related

<CardGroup cols={2}>
  <Card title="Planning" icon="list-check" href="/concepts/planning">
    Think before acting
  </Card>
  <Card title="Guardrails" icon="shield" href="/concepts/guardrails">
    Safety constraints
  </Card>
</CardGroup>
