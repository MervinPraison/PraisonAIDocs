---
title: "Handoff Module"
description: "Handoff functionality for agent-to-agent delegation.

This module provides handoff capabilities that allow agents to delegate tasks
to other agents, s"
icon: "arrow-right-arrow-left"
---

# handoff

Handoff functionality for agent-to-agent delegation.

This module provides handoff capabilities that allow agents to delegate tasks
to other agents, similar to the OpenAI Agents SDK implementation.

Unified Handoff System:
- Handoff: LLM-driven (tool call) or programmatic agent-to-agent transfer
- HandoffConfig: Configuration for context policy, timeouts, concurrency, safety
- Replaces/absorbs Agent.delegate() and SubagentDelegator functionality

## Import

```python
from praisonaiagents import handoff
```

## Classes

### ContextPolicy

Policy for context sharing during handoff.

### HandoffConfig

Unified configuration for handoff behavior.

This consolidates all handoff-related settings including context policy,
timeouts, concurrency control, and safety features.

Attributes:
    context_policy: How to share context during handoff (default: summary for safety)
    max_context_tokens: Maximum tokens to include in context
    max_context_messages: Maximum messages to include (for LAST_N policy)
    preserve_system: Whether to preserve system messages in context
    timeout_seconds: Timeout for handoff execution
    max_concurrent: Maximum concurrent handoffs (0 = unlimited)
    detect_cycles: Enable cycle detection to prevent infinite loops
    max_depth: Maximum handoff chain depth
    async_mode: Enable async execution
    on_handoff: Callback when handoff starts
    on_complete: Callback when handoff completes
    on_error: Callback when handoff fails

#### Methods

- **to_dict**(``) → `Dict[str, Any]`
  Convert config to dictionary.
- **from_dict**(`data: Dict[str, Any]`) → `HandoffConfig`
  Create config from dictionary.

### HandoffError

Base exception for handoff errors.

### HandoffCycleError

Raised when a cycle is detected in handoff chain.

#### Constructor Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `chain` | `List[str]` |  |

### HandoffDepthError

Raised when max handoff depth is exceeded.

#### Constructor Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `depth` | `int` |  |
| `max_depth` | `int` |  |

### HandoffTimeoutError

Raised when handoff times out.

#### Constructor Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `timeout` | `float` |  |
| `agent_name` | `str` |  |

### HandoffInputData

Data passed to a handoff target agent.

### HandoffResult

Result of a handoff operation.

### Handoff

Represents a handoff configuration for delegating tasks to another agent.

Handoffs are represented as tools to the LLM, allowing agents to transfer
control to specialized agents for specific tasks.

This is the unified mechanism for agent-to-agent task transfer, supporting:
- LLM-driven handoffs (via tool calls)
- Programmatic handoffs (direct Python API)
- Async handoffs with concurrency control
- Cycle detection and depth limiting
- Configurable context policies

#### Constructor Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `agent` | `Agent` |  |
| `tool_name_override` | `Optional[str]` |  |
| `tool_description_override` | `Optional[str]` |  |
| `on_handoff` | `Optional[Callable]` |  |
| `input_type` | `Optional[type]` |  |
| `input_filter` | `Optional[Callable[[HandoffInputData], HandoffInputData]]` |  |
| `config` | `Optional[HandoffConfig]` |  |

#### Methods

- **tool_name**(``) → `str`
  Get the tool name for this handoff.
- **tool_description**(``) → `str`
  Get the tool description for this handoff.
- **default_tool_name**(``) → `str`
  Generate default tool name based on agent name.
- **default_tool_description**(``) → `str`
  Generate default tool description based on agent role and goal.
- **execute_programmatic**(`source_agent: Agent, prompt: str, context: Optional[Dict[str, Any]]`) → `HandoffResult`
  Execute handoff programmatically (not via LLM tool call).

This is the unified programmatic handoff 
- **to_tool_function**(`source_agent: Agent`) → `Callable`
  Convert this handoff to a tool function that can be called by the LLM.

Args:
    source_agent: The 

### handoff_filters

Common handoff input filters.

#### Methods

- **remove_all_tools**(`data: HandoffInputData`) → `HandoffInputData`
  Remove all tool calls from the message history.
- **keep_last_n_messages**(`n: int`) → `Callable[[HandoffInputData], HandoffInputData]`
  Keep only the last n messages in the history.
- **remove_system_messages**(`data: HandoffInputData`) → `HandoffInputData`
  Remove all system messages from the history.

## Functions

### handoff()

Create a handoff configuration for delegating tasks to another agent.

This is a convenience function that creates a Handoff instance with the
specified configuration. It supports both the legacy API and the new
unified HandoffConfig.

Args:
    agent: The target agent to hand off to
    tool_name_override: Custom tool name (defaults to transfer_to_`<agent_name>`)
    tool_description_override: Custom tool description
    on_handoff: Callback function executed when handoff is invoked
    input_type: Type of input expected by the handoff (for structured data)
    input_filter: Function to filter/transform input before passing to target agent
    config: HandoffConfig for advanced settings
    context_policy: Shorthand for config.context_policy ("full", "summary", "none", "last_n")
    timeout_seconds: Shorthand for config.timeout_seconds
    max_concurrent: Shorthand for config.max_concurrent
    detect_cycles: Shorthand for config.detect_cycles
    max_depth: Shorthand for config.max_depth
    
Returns:
    A configured Handoff instance
    
Example:
    ```python
    from praisonaiagents import Agent, handoff, HandoffConfig
    
    billing_agent = Agent(name="Billing Agent")
    refund_agent = Agent(name="Refund Agent")
    
    # Simple usage
    triage_agent = Agent(
        name="Triage Agent",
        handoffs=[billing_agent, handoff(refund_agent)]
    )
    
    # With config
    triage_agent = Agent(
        name="Triage Agent",
        handoffs=[
            handoff(billing_agent, context_policy="summary", timeout_seconds=60),
            handoff(refund_agent, config=HandoffConfig(detect_cycles=True))
        ]
    )
    ```

```python
def handoff(agent: Agent, tool_name_override: Optional[str], tool_description_override: Optional[str], on_handoff: Optional[Callable], input_type: Optional[type], input_filter: Optional[Callable[[HandoffInputData], HandoffInputData]], config: Optional[HandoffConfig], context_policy: Optional[str], timeout_seconds: Optional[float], max_concurrent: Optional[int], detect_cycles: Optional[bool], max_depth: Optional[int]) -> Handoff
```

### prompt_with_handoff_instructions()

Add handoff instructions to an agent's prompt.

Args:
    base_prompt: The original prompt/instructions
    agent: The agent that will use handoffs
    
Returns:
    Updated prompt with handoff instructions

```python
def prompt_with_handoff_instructions(base_prompt: str, agent: Agent) -> str
```
