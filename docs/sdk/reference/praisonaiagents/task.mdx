---
title: "Task Module"
description: "API reference for task"
icon: "list-check"
---

# task



## Import

```python
from praisonaiagents import task
```

## Classes

### Task



#### Constructor Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `description` | `str` |  |
| `expected_output` | `Optional[str]` |  |
| `agent` | `Optional[Agent]` |  |
| `name` | `Optional[str]` |  |
| `tools` | `Optional[List[Any]]` |  |
| `context` | `Optional[List[Union[str, List, 'Task']]]` |  |
| `async_execution` | `Optional[bool]` |  |
| `config` | `Optional[Dict[str, Any]]` |  |
| `output_file` | `Optional[str]` |  |
| `output_json` | `Optional[Type[BaseModel]]` |  |
| `output_pydantic` | `Optional[Type[BaseModel]]` |  |
| `callback` | `Optional[Union[Callable[[TaskOutput], Any], Callable[[TaskOutput], Coroutine[Any, Any, Any]]]]` |  |
| `status` | `str` |  |
| `result` | `Optional[TaskOutput]` |  |
| `create_directory` | `Optional[bool]` |  |
| `id` | `Optional[int]` |  |
| `images` | `Optional[List[str]]` |  |
| `next_tasks` | `Optional[List[str]]` |  |
| `task_type` | `str` |  |
| `condition` | `Optional[Dict[str, List[str]]]` |  |
| `is_start` | `bool` |  |
| `loop_state` | `Optional[Dict[str, Union[str, int]]]` |  |
| `memory` | `Any` |  |
| `quality_check` | `Any` |  |
| `input_file` | `Optional[str]` |  |
| `rerun` | `bool` |  |
| `retain_full_context` | `bool` |  |
| `guardrail` | `Optional[Union[Callable[[TaskOutput], Tuple[bool, Any]], str]]` |  |
| `guardrails` | `Optional[Union[Callable[[TaskOutput], Tuple[bool, Any]], str]]` |  |
| `max_retries` | `int` |  |
| `retry_count` | `int` |  |
| `agent_config` | `Optional[Dict[str, Any]]` |  |
| `variables` | `Optional[Dict[str, Any]]` |  |

#### Methods

- **initialize_memory**(``) → `Any`
  Initialize memory if config exists but memory doesn't
- **store_in_memory**(`content: str, agent_name: str, task_id: str`) → `Any`
  Store content in memory with metadata
- **execute_callback_sync**(`task_output: TaskOutput`) → `None`
  Synchronous wrapper to ensure that execute_callback is awaited,
preventing 'Task was destroyed but p
