---
title: "parse_utils"
description: "Parse Utilities for Consolidated Parameter Resolution."
icon: "file-magnifying-glass"
---

# parse_utils

<Badge color="blue">Core SDK</Badge>

Parse Utilities for Consolidated Parameter Resolution.

Provides O(1) utility functions for parameter parsing:
- URL detection and parsing
- Path detection
- Typo suggestion (only on error path)
- Error message generation

Performance: All happy-path operations are O(1).
Typo suggestion uses Levenshtein distance only when raising errors.

## Import

```python
from praisonaiagents import parse_utils
```

## Functions

### detect_url_scheme()

Detect URL scheme from a string. O(1) operation.

Args:
    value: String to check for URL scheme
    
Returns:
    Scheme name (lowercase) if URL detected, None otherwise
    
Examples:
    &gt;&gt;&gt; detect_url_scheme("postgresql://localhost/db")
    'postgresql'
    &gt;&gt;&gt; detect_url_scheme("redis://localhost:6379")
    'redis'
    &gt;&gt;&gt; detect_url_scheme("not a url")
    None

```python
def detect_url_scheme(value: str) -> Optional
```

<Expandable title="Parameters">

- **value** (`str`)

</Expandable>

### parse_url_to_config()

Parse a URL string into a config object.

Args:
    url: URL string (e.g., "postgresql://localhost/db")
    config_class: Config dataclass to instantiate
    url_schemes: Mapping of URL schemes to backend names
    
Returns:
    Config instance with backend and url set
    
Raises:
    ValueError: If URL scheme is not supported

```python
def parse_url_to_config(url: str, config_class: type, url_schemes: Dict) -> Any
```

<Expandable title="Parameters">

- **url** (`str`)
- **config_class** (`type`)
- **url_schemes** (`Dict`)

</Expandable>

### is_path_like()

Check if a string looks like a file path. O(1) operation.

Args:
    value: String to check
    
Returns:
    True if string looks like a path
    
Examples:
    &gt;&gt;&gt; is_path_like("docs/")
    True
    &gt;&gt;&gt; is_path_like("./data.pdf")
    True
    &gt;&gt;&gt; is_path_like("verbose")
    False

```python
def is_path_like(value: str) -> bool
```

<Expandable title="Parameters">

- **value** (`str`)

</Expandable>

### is_numeric_string()

Check if a string is numeric. O(1) operation.

Args:
    value: String to check
    
Returns:
    True if string is numeric

```python
def is_numeric_string(value: str) -> bool
```

<Expandable title="Parameters">

- **value** (`str`)

</Expandable>

### suggest_similar()

Find the most similar string from candidates using Levenshtein distance.

This function is ONLY called on error paths, never on happy paths.

Args:
    value: The invalid value
    candidates: Valid options to compare against
    max_distance: Maximum edit distance to consider a match
    
Returns:
    Most similar candidate if within max_distance, None otherwise

```python
def suggest_similar(value: str, candidates: Iterable) -> Optional
```

<Expandable title="Parameters">

- **value** (`str`)
- **candidates** (`Iterable`)
- **max_distance** (`int`)

</Expandable>

### make_preset_error()

Create a helpful error message for invalid preset.

Args:
    param_name: Name of the parameter
    value: Invalid value provided
    presets: Valid preset options
    url_schemes: Optional URL schemes if applicable
    
Returns:
    ValueError with helpful message

```python
def make_preset_error(param_name: str, value: str, presets: Iterable) -> ValueError
```

<Expandable title="Parameters">

- **param_name** (`str`)
- **value** (`str`)
- **presets** (`Iterable`)
- **url_schemes** (`Optional`)

</Expandable>

### make_array_error()

Create a helpful error message for invalid array format.

Args:
    param_name: Name of the parameter
    value: Invalid array value
    expected_format: Description of expected format
    
Returns:
    ValueError with helpful message

```python
def make_array_error(param_name: str, value: list, expected_format: str) -> ValueError
```

<Expandable title="Parameters">

- **param_name** (`str`)
- **value** (`list`)
- **expected_format** (`str`)

</Expandable>

### is_policy_string()

Check if a string is a policy specification. O(1) operation.

Policy strings have format: type:action (e.g., "policy:strict", "pii:redact")

Args:
    value: String to check
    
Returns:
    True if string is a policy specification
    
Examples:
    &gt;&gt;&gt; is_policy_string("policy:strict")
    True
    &gt;&gt;&gt; is_policy_string("pii:redact")
    True
    &gt;&gt;&gt; is_policy_string("strict")
    False

```python
def is_policy_string(value: str) -> bool
```

<Expandable title="Parameters">

- **value** (`str`)

</Expandable>

### parse_policy_string()

Parse a policy string into type and action. O(1) operation.

Args:
    value: Policy string (e.g., "policy:strict", "pii:redact")
    
Returns:
    Tuple of (policy_type, action)
    
Examples:
    &gt;&gt;&gt; parse_policy_string("policy:strict")
    ('policy', 'strict')
    &gt;&gt;&gt; parse_policy_string("pii:redact")
    ('pii', 'redact')

```python
def parse_policy_string(value: str) -> tuple
```

<Expandable title="Parameters">

- **value** (`str`)

</Expandable>

### merge_config_with_overrides()

Merge a base config with override dict.

Args:
    base_config: Base config instance
    overrides: Dict of field overrides
    config_class: Config class for creating new instance
    
Returns:
    New config instance with overrides applied

```python
def merge_config_with_overrides(base_config: Any, overrides: Dict) -> Any
```

<Expandable title="Parameters">

- **base_config** (`Any`)
- **overrides** (`Dict`)
- **config_class** (`type`)

</Expandable>
