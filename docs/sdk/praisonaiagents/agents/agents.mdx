---
title: "Agents Module"
description: "Documentation for the praisonaiagents.agents.agents module"
icon: "users"
---

# Module praisonaiagents.agents.agents

The `Agents` class (also available as `PraisonAIAgents` for backward compatibility) provides multi-agent orchestration with support for sequential, parallel, hierarchical, and workflow-based execution patterns.

## Quick Start

```python
from praisonaiagents import Agent, Task, Agents

# Create agents
researcher = Agent(name="Researcher", instructions="Research topics thoroughly")
writer = Agent(name="Writer", instructions="Write clear, engaging content")

# Create tasks
research_task = Task(
    description="Research AI trends",
    agent=researcher,
    expected_output="Research summary"
)
write_task = Task(
    description="Write article based on research",
    agent=writer,
    context=[research_task],
    expected_output="Article draft"
)

# Run multi-agent workflow
agents = Agents(agents=[researcher, writer], tasks=[research_task, write_task])
result = agents.start()
```

## Classes

### Agents

The main class for managing multi-agent task execution. **Canonical name** - use `Agents` instead of `PraisonAIAgents`.

#### Parameters

- `agents: List[Agent]` - List of agents to orchestrate
- `tasks: List[Task]` - List of tasks to execute
- `verbose: int = 0` - Verbosity level (0=minimal, 1=normal, 2=debug)
- `process: str = "sequential"` - Execution process type:
  - `"sequential"` - Execute tasks in order
  - `"parallel"` - Execute independent tasks concurrently
  - `"hierarchical"` - Manager agent delegates to workers
  - `"workflow"` - Follow task dependencies
- `manager_llm: Optional[str] = None` - LLM for manager agent (hierarchical mode)
- `manager_agent: Optional[Agent] = None` - Custom manager agent
- `memory: Optional[Any] = None` - Shared memory configuration
- `max_retries: int = 5` - Maximum retry attempts per task
- `completion_checker: Optional[Callable] = None` - Custom completion validator
- `embedder: Optional[Dict] = None` - Embedder configuration for knowledge
- `user_id: Optional[str] = None` - User ID for memory isolation

#### Methods

**Execution**
- `start()` - Start synchronous execution, returns results dict
- `astart()` - Async version of start
- `run_all_tasks()` - Execute all tasks based on process type
- `arun_all_tasks()` - Async version
- `execute_task(task_id)` - Execute a specific task
- `aexecute_task(task_id)` - Async version

**Task Management**
- `add_task(task)` - Add a task dynamically
- `get_task_status(task_id)` - Get task status
- `get_task_result(task_id)` - Get task result
- `get_all_tasks_status()` - Get all task statuses
- `get_task_details(task_id)` - Get full task details

**State Management**
- `set_state(key, value)` - Set a shared state value
- `get_state(key, default=None)` - Get a shared state value
- `update_state(updates: Dict)` - Update multiple state values
- `clear_state()` - Clear all state

**Agent Management**
- `get_agent_details(agent_name)` - Get agent details

## Process Types

### Sequential (Default)

Tasks execute one after another in order:

```python
agents = Agents(
    agents=[agent1, agent2],
    tasks=[task1, task2, task3],
    process="sequential"
)
```

### Parallel

Independent tasks execute concurrently:

```python
agents = Agents(
    agents=[agent1, agent2, agent3],
    tasks=[independent_task1, independent_task2, independent_task3],
    process="parallel"
)
```

### Hierarchical

Manager agent delegates to worker agents:

```python
agents = Agents(
    agents=[worker1, worker2, worker3],
    tasks=[complex_task],
    process="hierarchical",
    manager_llm="gpt-4o-mini"
)
```

### Workflow

Tasks follow explicit dependencies via `context`:

```python
task1 = Task(description="Step 1", agent=agent1)
task2 = Task(description="Step 2", agent=agent2, context=[task1])
task3 = Task(description="Step 3", agent=agent3, context=[task1, task2])

agents = Agents(
    agents=[agent1, agent2, agent3],
    tasks=[task1, task2, task3],
    process="workflow"
)
```

## Async Support

Full async/await support for non-blocking execution:

```python
import asyncio
from praisonaiagents import Agent, Task, Agents

async def main():
    agents = Agents(
        agents=[agent1, agent2],
        tasks=[task1, task2],
        process="workflow"
    )
    
    result = await agents.astart()
    print(result["task_results"])

asyncio.run(main())
```

## Shared State

Agents can share state during execution:

```python
agents = Agents(agents=[agent1, agent2], tasks=[task1, task2])

# Set shared state
agents.set_state("api_key", "xxx")
agents.set_state("config", {"mode": "production"})

# Access in tasks via context
result = agents.start()

# Read state after execution
final_data = agents.get_state("collected_data")
```

## Advanced Examples

### With Memory

```python
agents = Agents(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    memory=True,  # Enable shared memory
    user_id="user123"
)
```

### With Custom Completion Checker

```python
def my_checker(task, output):
    """Custom validation for task completion."""
    if "error" in output.lower():
        return False, "Output contains errors"
    return True, output

agents = Agents(
    agents=[agent1],
    tasks=[task1],
    completion_checker=my_checker
)
```

### With Verbose Logging

```python
agents = Agents(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    verbose=2  # Debug level
)
```

## See Also

- [Agent Module](/docs/sdk/praisonaiagents/agent/agent) - Individual agents
- [Task Module](/docs/sdk/praisonaiagents/task/task) - Task definition
- [Process Module](/docs/sdk/praisonaiagents/process/process) - Execution flows
- [AutoAgents](/docs/sdk/praisonaiagents/agents/autoagents) - Auto-generated agents