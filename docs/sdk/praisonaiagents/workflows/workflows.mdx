---
title: "Workflows"
description: "Workflow and pipeline patterns for orchestrating agents and functions"
icon: "sitemap"
---

# Workflows Module

The workflows module provides workflow/pipeline patterns for orchestrating agents and functions with support for routing, parallel execution, loops, and more.

## Installation

```bash
pip install praisonaiagents
```

## Quick Start

```python
from praisonaiagents import Workflow, Agent

# Define agents
researcher = Agent(name="Researcher", role="Research Assistant")
writer = Agent(name="Writer", role="Content Writer")

# Create workflow
workflow = Workflow(
    steps=[
        {"agent": researcher, "task": "Research the topic"},
        {"agent": writer, "task": "Write article based on research"}
    ]
)

result = workflow.run(topic="AI trends")
```

## Core Classes

### Workflow (Pipeline)

Main class for defining multi-step workflows.

```python
from praisonaiagents import Workflow, Pipeline  # Pipeline is alias

workflow = Workflow(
    name="Content Pipeline",
    steps=[step1, step2, step3],
    context={"key": "value"}
)

result = workflow.run(input_data)
```

#### Constructor

| Parameter | Type | Description |
|-----------|------|-------------|
| `name` | `str` | Workflow name |
| `steps` | `list` | List of workflow steps |
| `context` | `dict` | Initial context data |

#### Methods

| Method | Description |
|--------|-------------|
| `run(input)` | Execute the workflow |
| `run_async(input)` | Execute asynchronously |
| `add_step(step)` | Add a step to the workflow |
| `get_context()` | Get current context |

### WorkflowStep

A single step in a workflow.

```python
from praisonaiagents import WorkflowStep

step = WorkflowStep(
    name="research",
    agent=researcher,
    task="Research the topic",
    condition=lambda ctx: ctx.get("needs_research", True)
)
```

#### Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `name` | `str` | Step name |
| `agent` | `Agent` | Agent to execute the step |
| `task` | `str` | Task description |
| `condition` | `callable` | Condition for execution |
| `on_success` | `str` | Next step on success |
| `on_failure` | `str` | Next step on failure |

### WorkflowContext

Context passed between workflow steps.

```python
from praisonaiagents import WorkflowContext

context = WorkflowContext(
    initial_data={"topic": "AI"},
    metadata={"user_id": "123"}
)

# Access data
context.set("key", "value")
value = context.get("key")
```

### StepResult

Result from a workflow step.

```python
from praisonaiagents import StepResult

result = StepResult(
    success=True,
    output="Step completed",
    metadata={"duration": 1.5}
)
```

### WorkflowManager

Manager for complex workflow orchestration.

```python
from praisonaiagents.workflows import WorkflowManager

manager = WorkflowManager()
manager.register_workflow("content", content_workflow)
manager.register_workflow("analysis", analysis_workflow)

result = manager.run("content", input_data)
```

## Pattern Helpers

### Route

Conditional routing between steps.

```python
from praisonaiagents import Route, route

# Class-based
routing = Route(
    condition=lambda ctx: ctx.get("type"),
    routes={
        "technical": technical_agent,
        "creative": creative_agent
    },
    default=general_agent
)

# Function-based
@route(condition=lambda ctx: ctx.get("type"))
def my_router(ctx):
    if ctx.get("type") == "technical":
        return technical_agent
    return general_agent
```

### Parallel

Execute steps in parallel.

```python
from praisonaiagents import Parallel, parallel

# Class-based
parallel_steps = Parallel(
    steps=[agent1, agent2, agent3],
    merge_strategy="combine"  # or "first", "all"
)

# Function-based
@parallel(merge_strategy="combine")
def parallel_research():
    return [web_search, database_search, api_search]
```

### Loop

Loop until condition is met.

```python
from praisonaiagents import Loop, loop

# Class-based
refinement_loop = Loop(
    step=refine_agent,
    condition=lambda ctx: ctx.get("quality_score", 0) < 0.9,
    max_iterations=5
)

# Function-based
@loop(max_iterations=5)
def refine_until_good(ctx):
    return ctx.get("quality_score", 0) < 0.9
```

### Repeat

Repeat a step N times.

```python
from praisonaiagents import Repeat, repeat

# Class-based
repeated = Repeat(
    step=generate_agent,
    times=3
)

# Function-based
@repeat(times=3)
def generate_variations():
    return generate_agent
```

## YAML Workflows

Parse workflows from YAML files.

```python
from praisonaiagents.workflows import YAMLWorkflowParser

parser = YAMLWorkflowParser()
workflow = parser.parse("workflow.yaml")
result = workflow.run()
```

### YAML Format

```yaml
name: Content Pipeline
steps:
  - name: research
    agent: researcher
    task: Research the topic
    
  - name: write
    agent: writer
    task: Write article
    depends_on: research
    
  - name: review
    agent: reviewer
    task: Review and edit
    depends_on: write
```

## Usage Examples

### Sequential Workflow

```python
from praisonaiagents import Workflow, Agent

researcher = Agent(name="Researcher")
writer = Agent(name="Writer")
editor = Agent(name="Editor")

workflow = Workflow(steps=[
    {"agent": researcher, "task": "Research {topic}"},
    {"agent": writer, "task": "Write article based on research"},
    {"agent": editor, "task": "Edit and polish the article"}
])

result = workflow.run(topic="Machine Learning")
```

### Conditional Workflow

```python
from praisonaiagents import Workflow, Route

workflow = Workflow(steps=[
    {"agent": classifier, "task": "Classify the request"},
    Route(
        condition=lambda ctx: ctx.get("category"),
        routes={
            "technical": technical_agent,
            "billing": billing_agent,
            "general": general_agent
        }
    )
])
```

### Parallel Processing

```python
from praisonaiagents import Workflow, Parallel

workflow = Workflow(steps=[
    {"agent": planner, "task": "Create research plan"},
    Parallel(steps=[
        {"agent": web_researcher, "task": "Search web"},
        {"agent": db_researcher, "task": "Search database"},
        {"agent": api_researcher, "task": "Query APIs"}
    ]),
    {"agent": synthesizer, "task": "Combine all research"}
])
```

### Loop with Refinement

```python
from praisonaiagents import Workflow, Loop

workflow = Workflow(steps=[
    {"agent": generator, "task": "Generate initial draft"},
    Loop(
        step={"agent": refiner, "task": "Improve the draft"},
        condition=lambda ctx: ctx.get("score", 0) < 0.9,
        max_iterations=3
    ),
    {"agent": finalizer, "task": "Finalize output"}
])
```

## Related

- [WorkflowManager](/docs/sdk/praisonaiagents/workflows/workflow-manager) - Detailed workflow manager docs
- [Agent](/docs/sdk/praisonaiagents/agent/agent) - Agent configuration
- [Task](/docs/sdk/praisonaiagents/task/task) - Task definition
