---
title: "Autonomous Loops"
description: "Run agents in self-referential execution loops with completion signals"
icon: "rotate"
---

Autonomous loops let agents work iteratively on complex tasks, automatically stopping when they signal completion or reach limits.

```mermaid
flowchart LR
    A[Start Loop] --> B[Execute Task]
    B --> C{Check Completion}
    C -->|Promise Found| D[âœ… Success]
    C -->|Max Iterations| E[âš ï¸ Limit Reached]
    C -->|Doom Loop| F[ðŸ›‘ Stopped]
    C -->|Continue| G[Clear Context?]
    G -->|Yes| H[Reset Memory]
    G -->|No| B
    H --> B
    
    style A fill:#8B0000,color:#fff
    style D fill:#189AB4,color:#fff
    style E fill:#189AB4,color:#fff
    style F fill:#189AB4,color:#fff
```

## Quick Start

<CodeGroup>
```python Basic Loop
from praisonaiagents import Agent

agent = Agent(
    name="builder",
    instructions="Build the requested feature",
    autonomy=True
)

result = agent.run_autonomous(
    "Create a REST API with user authentication",
    max_iterations=10
)

print(f"Success: {result.success}")
print(f"Iterations: {result.iterations}")
```

```python With Completion Promise
from praisonaiagents import Agent

agent = Agent(
    name="builder",
    instructions="""Build the feature. When done, output:
    <promise>DONE</promise>""",
    autonomy=True
)

result = agent.run_autonomous(
    "Create a calculator module",
    completion_promise="DONE",
    max_iterations=20
)
```

```python With Context Clearing
from praisonaiagents import Agent

agent = Agent(
    name="builder",
    instructions="Work on the task. Use files for state.",
    autonomy=True
)

result = agent.run_autonomous(
    "Refactor the auth module",
    completion_promise="COMPLETE",
    clear_context=True,  # Fresh memory each iteration
    max_iterations=15
)
```
</CodeGroup>

## How It Works

```mermaid
sequenceDiagram
    participant U as User
    participant A as Agent
    participant L as LLM
    participant S as State
    
    U->>A: run_autonomous(prompt)
    loop Each Iteration
        A->>L: Send prompt
        L->>A: Response
        A->>A: Check for promise tag
        alt Promise found
            A->>U: âœ… Success
        else Max iterations
            A->>U: âš ï¸ Limit reached
        else Doom loop
            A->>U: ðŸ›‘ Stopped
        else Continue
            A->>S: Clear context (optional)
            A->>A: Next iteration
        end
    end
    
    style U fill:#8B0000,color:#fff
    style A fill:#8B0000,color:#fff
    style L fill:#189AB4,color:#fff
    style S fill:#189AB4,color:#fff
```

## Key Features

<CardGroup cols={2}>
  <Card title="Completion Promise" icon="flag-checkered">
    Agent signals "done" with a promise tag containing TEXT
  </Card>
  <Card title="Context Clearing" icon="eraser">
    Fresh memory each iteration forces file-based state
  </Card>
  <Card title="Doom Loop Detection" icon="shield">
    Automatically stops on repeated identical actions
  </Card>
  <Card title="Iteration Limits" icon="stopwatch">
    Prevents runaway execution with configurable max
  </Card>
</CardGroup>

## Configuration

### AutonomyConfig Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `max_iterations` | int | 20 | Maximum loop iterations |
| `completion_promise` | str | None | Text to detect in promise tags |
| `clear_context` | bool | False | Clear chat history between iterations |
| `doom_loop_threshold` | int | 3 | Repeated actions before stopping |

### Using Config Dict

```python
agent = Agent(
    name="worker",
    instructions="Complete the task",
    autonomy={
        "max_iterations": 30,
        "completion_promise": "FINISHED",
        "clear_context": True,
        "doom_loop_threshold": 5
    }
)
```

## CLI Usage

<Tabs>
  <Tab title="Basic">
    ```bash
    praisonai loop "Build a REST API" -n 5
    ```
  </Tab>
  <Tab title="With Promise">
    ```bash
    praisonai loop "Refactor auth module" -p DONE -v
    ```
  </Tab>
  <Tab title="With Context Clearing">
    ```bash
    praisonai loop "Implement feature X" -p COMPLETE -c -n 20
    ```
  </Tab>
  <Tab title="With Timeout">
    ```bash
    praisonai loop "Debug the issue" -t 300 -v
    ```
  </Tab>
</Tabs>

### CLI Options

| Flag | Description |
|------|-------------|
| `-n, --max-iterations` | Maximum iterations (default: 10) |
| `-p, --completion-promise` | Promise text to signal completion |
| `-c, --clear-context` | Clear chat history between iterations |
| `-t, --timeout` | Timeout in seconds |
| `-m, --model` | LLM model to use |
| `-v, --verbose` | Show verbose output |

## Result Object

```python
result = agent.run_autonomous(prompt, ...)

# Available fields
result.success          # bool - Task completed successfully
result.output           # str - Final response
result.completion_reason # str - "promise", "goal", "max_iterations", "doom_loop", "timeout", "error"
result.iterations       # int - Number of iterations executed
result.duration_seconds # float - Total execution time
result.started_at       # str - ISO 8601 timestamp when execution started
result.actions          # list - Actions taken each iteration
result.error            # str | None - Error message if failed
```

## Completion Reasons

<AccordionGroup>
  <Accordion title="promise">
    Agent output contained a promise tag with TEXT matching the configured promise.
  </Accordion>
  <Accordion title="goal">
    Agent output contained completion keywords like "task completed" or "done".
  </Accordion>
  <Accordion title="max_iterations">
    Reached the maximum iteration limit without completion signal.
  </Accordion>
  <Accordion title="doom_loop">
    Detected repeated identical actions (agent stuck in a loop).
  </Accordion>
  <Accordion title="timeout">
    Execution exceeded the configured timeout.
  </Accordion>
  <Accordion title="error">
    An error occurred during execution.
  </Accordion>
</AccordionGroup>

## Best Practices

<Steps>
  <Step title="Use Completion Promises">
    Always set a `completion_promise` for reliable termination instead of relying on keyword detection.
  </Step>
  <Step title="Enable Context Clearing for Long Tasks">
    Use `clear_context=True` for tasks that should rely on file state rather than conversation memory.
  </Step>
  <Step title="Set Reasonable Limits">
    Configure `max_iterations` based on task complexity. Start low and increase if needed.
  </Step>
  <Step title="Include Promise in Instructions">
    Tell the agent to output the promise tag when done:
    ```python
    instructions="When finished, output DONE in a promise tag"
    ```
  </Step>
</Steps>

## Async Execution

Run autonomous loops asynchronously for concurrent agent execution:

```mermaid
flowchart LR
    A[Start] --> B[Agent 1]
    A --> C[Agent 2]
    A --> D[Agent 3]
    B --> E[Results]
    C --> E
    D --> E
    E --> F[Done]
    
    style A fill:#8B0000,color:#fff
    style B fill:#189AB4,color:#fff
    style C fill:#189AB4,color:#fff
    style D fill:#189AB4,color:#fff
    style F fill:#8B0000,color:#fff
```

<CodeGroup>
```python Single Async Agent
import asyncio
from praisonaiagents import Agent

async def main():
    agent = Agent(
        name="async_worker",
        instructions="Complete the task. Output <promise>DONE</promise> when finished.",
        autonomy=True
    )
    
    result = await agent.run_autonomous_async(
        "Build a calculator",
        completion_promise="DONE",
        max_iterations=10
    )
    
    print(f"Success: {result.success}")
    print(f"Started: {result.started_at}")

asyncio.run(main())
```

```python Concurrent Agents
import asyncio
from praisonaiagents import Agent

async def main():
    agent1 = Agent(name="researcher", instructions="Research the topic", autonomy=True)
    agent2 = Agent(name="writer", instructions="Write content", autonomy=True)
    
    # Run both agents concurrently
    results = await asyncio.gather(
        agent1.run_autonomous_async("Research AI trends", completion_promise="DONE"),
        agent2.run_autonomous_async("Write a blog post", completion_promise="DONE")
    )
    
    for i, result in enumerate(results):
        print(f"Agent {i+1}: {result.completion_reason}")

asyncio.run(main())
```
</CodeGroup>

<Note>
`run_autonomous_async()` uses `achat()` internally for non-blocking I/O, enabling true concurrent execution of multiple agents.
</Note>

## Example: Self-Improving Code

```python
from praisonaiagents import Agent

agent = Agent(
    name="improver",
    instructions="""You are a code improvement agent.
    
    1. Read the current code
    2. Identify one improvement
    3. Make the change
    4. Verify it works
    5. If no more improvements needed, output <promise>OPTIMIZED</promise>
    """,
    autonomy=True,
    tools=[read_file, write_file, run_tests]
)

result = agent.run_autonomous(
    "Optimize the performance of src/utils.py",
    completion_promise="OPTIMIZED",
    clear_context=True,
    max_iterations=10
)

if result.success:
    print(f"Code optimized in {result.iterations} iterations")
    print(f"Started: {result.started_at}")
else:
    print(f"Stopped: {result.completion_reason}")
```

## Related

<CardGroup cols={2}>
  <Card title="Agent Autonomy" icon="robot" href="/features/autonomy">
    Core autonomy configuration
  </Card>
  <Card title="Background Jobs" icon="clock" href="/features/background">
    Run agents in the background
  </Card>
</CardGroup>
