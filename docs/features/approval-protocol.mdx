---
title: "Approval Protocol"
sidebarTitle: "Approval Protocol"
description: "Extensible tool-execution approval system for agents"
icon: "shield-check"
---

Agents can require human approval before executing dangerous tools. Set `approval=True` on any agent to auto-approve, or pass a custom backend for console, webhook, Slack, or any approval channel.

```mermaid
graph LR
    subgraph "Approval Protocol"
        A[üîß Tool Call] --> B{üîí Required?}
        B -->|No| D[‚úÖ Execute]
        B -->|Yes| C[üìã Backend]
        C -->|Approved| D
        C -->|Denied| E[‚ùå Blocked]
    end

    classDef tool fill:#6366F1,stroke:#7C90A0,color:#fff
    classDef check fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef result fill:#10B981,stroke:#7C90A0,color:#fff
    classDef denied fill:#8B0000,stroke:#7C90A0,color:#fff

    class A tool
    class B,C check
    class D result
    class E denied
```

## Quick Start

<Steps>

<Step title="Auto-Approve (Bots / Trusted Envs)">
```python
from praisonaiagents import Agent

agent = Agent(
    name="bot",
    instructions="You are a helpful assistant.",
    approval=True
)
agent.start("List files in current directory")
```
</Step>

<Step title="Custom Approval Backend">
```python
from praisonaiagents import Agent
from praisonaiagents.approval import ApprovalRequest, ApprovalDecision

class WebhookBackend:
    async def request_approval(self, request: ApprovalRequest) -> ApprovalDecision:
        # POST to your approval service
        return ApprovalDecision(approved=True, approver="webhook")

    def request_approval_sync(self, request: ApprovalRequest) -> ApprovalDecision:
        return ApprovalDecision(approved=True, approver="webhook")

agent = Agent(
    name="bot",
    instructions="You are a helpful assistant.",
    approval=WebhookBackend()
)
agent.start("List files in current directory")
```
</Step>

<Step title="Default (Console Prompt)">
```python
from praisonaiagents import Agent

# No approval= param ‚Üí dangerous tools prompt in terminal
agent = Agent(
    name="interactive",
    instructions="You are a helpful assistant.",
)
agent.start("Delete temporary files")
```
</Step>

</Steps>

---

## How It Works

```mermaid
sequenceDiagram
    participant Agent
    participant Backend
    participant Registry

    Agent->>Agent: Check self._approval_backend
    alt Agent has approval backend
        Agent->>Backend: request_approval(ApprovalRequest)
        Backend-->>Agent: ApprovalDecision
    else No agent backend (fallback)
        Agent->>Registry: approve_sync(agent_name, tool, args)
        Registry->>Registry: Check: required? env? yaml? already?
        alt Fast path
            Registry-->>Agent: ApprovalDecision(approved=True)
        else Needs backend
            Registry->>Backend: request_approval(ApprovalRequest)
            Backend-->>Registry: ApprovalDecision
            Registry-->>Agent: ApprovalDecision
        end
    end
```

| Step | What Happens |
|------|-------------|
| **Agent backend** | `approval=True` or custom backend on the Agent is checked first |
| **Required?** | Only tools in the dangerous-tools set need approval |
| **Env check** | `PRAISONAI_AUTO_APPROVE=true` skips all prompts |
| **YAML check** | Tools listed in YAML `approve` field are auto-approved |
| **Already approved** | Once approved in a session, no re-prompt |
| **Backend** | ConsoleBackend (default), AutoApproveBackend, or your custom |

---

## Configuration Options

```mermaid
graph TB
    subgraph "Choose Your Approval Strategy"
        PARAM["ü§ñ Agent Parameter<br/>Agent(approval=True)"]
        ENV["üåç Environment Variable<br/>PRAISONAI_AUTO_APPROVE=true"]
        GLOBAL["üîß Global Registry<br/>set_backend(AutoApproveBackend())"]
        CUSTOM["üîå Custom Backend<br/>Agent(approval=MyBackend())"]
    end

    classDef param fill:#6366F1,stroke:#7C90A0,color:#fff
    classDef env fill:#10B981,stroke:#7C90A0,color:#fff
    classDef global fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef custom fill:#189AB4,stroke:#7C90A0,color:#fff

    class PARAM param
    class ENV env
    class GLOBAL global
    class CUSTOM custom
```

### Agent Parameter (Recommended)

| Value | Behavior |
|-------|----------|
| `approval=True` | Auto-approve all dangerous tools for this agent |
| `approval=False` / `None` | Use registry fallback (default: console prompt) |
| `approval=MyBackend()` | Use a custom approval backend for this agent |

### Other Methods

| Method | Scope | Use Case |
|--------|-------|----------|
| `PRAISONAI_AUTO_APPROVE=true` | All agents | CI/CD, testing |
| `get_approval_registry().set_backend(backend)` | All agents | Global policy |
| `get_approval_registry().set_backend(backend, agent_name="x")` | Single agent | Registry-level per-agent control |
| YAML `approve: [tool1, tool2]` | Per-task | Declarative configs |

---

## Built-in Backends

| Backend | Import | Behavior |
|---------|--------|----------|
| `AutoApproveBackend` | `from praisonaiagents import AutoApproveBackend` | Always approves |
| `ConsoleBackend` | `from praisonaiagents.approval import ConsoleBackend` | Rich terminal prompt (default) |
| `AgentApproval` | `from praisonaiagents.approval import AgentApproval` | Delegates to another AI agent |
| `SlackApproval` | `from praisonai.bots import SlackApproval` | Slack Block Kit + polling |
| `TelegramApproval` | `from praisonai.bots import TelegramApproval` | Telegram inline keyboard + polling |
| `DiscordApproval` | `from praisonai.bots import DiscordApproval` | Discord embed + text reply polling |
| `WebhookApproval` | `from praisonai.bots import WebhookApproval` | POST to webhook + poll status |
| `HTTPApproval` | `from praisonai.bots import HTTPApproval` | Local web dashboard |
| `CallbackBackend` | `from praisonaiagents.approval import CallbackBackend` | Wraps a legacy callback function |

---

## Custom Backend

Implement `request_approval` (async) and optionally `request_approval_sync` to create any approval channel:

```python
from praisonaiagents import Agent
from praisonaiagents.approval import ApprovalRequest, ApprovalDecision

class SlackBackend:
    async def request_approval(self, request: ApprovalRequest) -> ApprovalDecision:
        approved = await self._ask_slack(
            f"Approve {request.tool_name} for {request.agent_name}?"
        )
        return ApprovalDecision(
            approved=approved,
            approver="slack",
            metadata={"channel": "#approvals"},
        )

    def request_approval_sync(self, request: ApprovalRequest) -> ApprovalDecision:
        # Sync fallback for non-async tool execution
        return ApprovalDecision(approved=True, approver="slack")

agent = Agent(
    name="slack-bot",
    instructions="You are a helpful assistant.",
    approval=SlackBackend()
)
```

---

## Slack Approval

Route tool approvals to Slack ‚Äî get a rich message with tool details and reply **yes** or **no** to approve or deny.

```mermaid
sequenceDiagram
    participant Agent
    participant SlackApproval
    participant Slack

    Agent->>SlackApproval: request_approval(tool, args)
    SlackApproval->>Slack: Post Block Kit message
    Note over Slack: üîí Tool Approval Required<br/>Tool: execute_command<br/>Reply yes/no
    Slack-->>SlackApproval: User replies "yes"
    SlackApproval->>Slack: Update message ‚úÖ Approved
    SlackApproval-->>Agent: ApprovalDecision(approved=True)
```

<Steps>

<Step title="Install">
```bash
pip install praisonai
```
</Step>

<Step title="Set Token">
```bash
export SLACK_BOT_TOKEN=xoxb-your-token
```
</Step>

<Step title="Use It">
```python
from praisonaiagents import Agent
from praisonai.bots import SlackApproval

agent = Agent(
    name="assistant",
    instructions="You are a helpful assistant.",
    tools=[execute_command],
    approval=SlackApproval(channel="#approvals")
)
agent.start("Delete old log files")
```
</Step>

</Steps>

<Tip>
  The Slack bot token needs `chat:write` and `channels:history` (or `im:history` for DMs) scopes.
</Tip>

### Configuration

| Parameter | Default | Description |
|-----------|---------|-------------|
| `token` | `SLACK_BOT_TOKEN` env | Slack bot token (`xoxb-...`) |
| `channel` | Bot's own DM | Channel ID, name, or user ID |
| `timeout` | `300` (5 min) | Seconds to wait for response |
| `poll_interval` | `3.0` | Seconds between polls |

### Approval Keywords

| Action | Keywords |
|--------|----------|
| **Approve** | yes, y, approve, approved, ok, allow, go, proceed, confirm |
| **Deny** | no, n, deny, denied, reject, block, stop, cancel, refuse |

<Accordion title="Cross-Platform: Telegram Bot ‚Üí Slack Approval">
You can use **any** bot platform for user interaction while routing approvals to Slack:

```python
from praisonaiagents import Agent
from praisonai.bots import Bot, SlackApproval

agent = Agent(
    name="assistant",
    instructions="You are a helpful assistant.",
    approval=SlackApproval(channel="U0ABPEV1HK8")  # DM to admin
)

# Users talk via Telegram; dangerous tools approved in Slack
bot = Bot("telegram", agent=agent)
bot.run()
```
</Accordion>

---

## Telegram Approval

Route tool approvals to Telegram ‚Äî get a message with inline keyboard buttons.

```mermaid
sequenceDiagram
    participant Agent
    participant TelegramApproval
    participant Telegram

    Agent->>TelegramApproval: request_approval(tool, args)
    TelegramApproval->>Telegram: sendMessage + InlineKeyboard
    Note over Telegram: üîí Tool Approval Required<br/>‚úÖ Approve  ‚ùå Deny
    Telegram-->>TelegramApproval: callback_query "approve"
    TelegramApproval->>Telegram: editMessageText ‚úÖ Approved
    TelegramApproval-->>Agent: ApprovalDecision(approved=True)
```

```python
from praisonaiagents import Agent
from praisonai.bots import TelegramApproval

agent = Agent(
    name="assistant",
    tools=[execute_command],
    approval=TelegramApproval(chat_id="YOUR_CHAT_ID")  # token from TELEGRAM_BOT_TOKEN env
)
```

| Parameter | Default | Description |
|-----------|---------|-------------|
| `token` | `TELEGRAM_BOT_TOKEN` env | Telegram bot token |
| `chat_id` | _(required)_ | Chat ID to send approvals to |
| `timeout` | `300` (5 min) | Seconds to wait for response |
| `poll_interval` | `2.0` | Seconds between polls |

---

## Discord Approval

Route tool approvals to Discord ‚Äî get a rich embed and reply **yes** or **no**.

```python
from praisonaiagents import Agent
from praisonai.bots import DiscordApproval

agent = Agent(
    name="assistant",
    tools=[execute_command],
    approval=DiscordApproval(channel_id="YOUR_CHANNEL_ID")  # token from DISCORD_BOT_TOKEN env
)
```

| Parameter | Default | Description |
|-----------|---------|-------------|
| `token` | `DISCORD_BOT_TOKEN` env | Discord bot token |
| `channel_id` | _(required)_ | Channel ID to send approvals to |
| `timeout` | `300` (5 min) | Seconds to wait for response |
| `poll_interval` | `3.0` | Seconds between polls |

---

## Webhook Approval

POST approval requests to any HTTP endpoint and poll for decisions. Ideal for enterprise dashboards, CI/CD, and custom integrations.

```mermaid
sequenceDiagram
    participant Agent
    participant WebhookApproval
    participant Server

    Agent->>WebhookApproval: request_approval(tool, args)
    WebhookApproval->>Server: POST /approve {tool, args, risk}
    Server-->>WebhookApproval: {status: "pending"}
    loop Poll
        WebhookApproval->>Server: GET /approve/{request_id}
        Server-->>WebhookApproval: {approved: true}
    end
    WebhookApproval-->>Agent: ApprovalDecision(approved=True)
```

```python
from praisonaiagents import Agent
from praisonai.bots import WebhookApproval

agent = Agent(
    name="assistant",
    tools=[execute_command],
    approval=WebhookApproval(
        webhook_url="https://your-app.com/api/approvals",
        headers={"Authorization": "Bearer sk-xxx"},
    ),
)
```

| Parameter | Default | Description |
|-----------|---------|-------------|
| `webhook_url` | `APPROVAL_WEBHOOK_URL` env | URL to POST requests to |
| `status_url` | `webhook_url/{request_id}` | URL template for polling |
| `headers` | `{}` | Extra HTTP headers (e.g. auth) |
| `timeout` | `300` (5 min) | Seconds to wait |
| `poll_interval` | `5.0` | Seconds between polls |

<Tip>
  If the webhook returns `{"approved": true}` in the POST response, the decision is immediate ‚Äî no polling needed.
</Tip>

---

## Agent Approval

Delegate approval decisions to another AI agent. The approver agent evaluates the tool call and responds with APPROVE or DENY.

```python
from praisonaiagents import Agent
from praisonaiagents.approval import AgentApproval

# Security reviewer agent
reviewer = Agent(
    name="security-reviewer",
    instructions="Only approve low-risk read operations. Deny anything destructive.",
)

worker = Agent(
    name="assistant",
    tools=[execute_command],
    approval=AgentApproval(approver_agent=reviewer),
)
```

| Parameter | Default | Description |
|-----------|---------|-------------|
| `approver_agent` | Auto-created | Agent instance to evaluate requests |
| `llm` | `gpt-4o-mini` | LLM for default approver agent |

<Note>
  `AgentApproval` lives in the core SDK (`praisonaiagents.approval`) ‚Äî no extra dependencies needed.
</Note>

---

## HTTP Approval

Serve a local web dashboard for approvals. Open the URL in your browser and click Approve or Deny.

```python
from praisonaiagents import Agent
from praisonai.bots import HTTPApproval

agent = Agent(
    name="assistant",
    tools=[execute_command],
    approval=HTTPApproval(host="127.0.0.1", port=8899),
)
# When a tool needs approval, open http://127.0.0.1:8899/approve/<request_id>
```

| Parameter | Default | Description |
|-----------|---------|-------------|
| `host` | `127.0.0.1` | Bind address |
| `port` | `8899` | Port to listen on |
| `timeout` | `300` (5 min) | Seconds to wait for response |

---

## Multi-Agent Example

Different agents can have different approval policies:

```python
from praisonaiagents import Agent
from praisonaiagents.approval import AgentApproval
from praisonai.bots import SlackApproval, TelegramApproval, HTTPApproval

# Bot agent: auto-approve everything
bot = Agent(name="bot", approval=True)

# Interactive agent: console prompt (default)
interactive = Agent(name="interactive")

# Slack-approved agent
slack_agent = Agent(name="slack-approved", approval=SlackApproval(channel="#approvals"))

# Telegram-approved agent
telegram_agent = Agent(name="tg-approved", approval=TelegramApproval(chat_id="123456"))

# AI-reviewed agent (no human needed)
reviewer = Agent(name="reviewer", instructions="Only approve safe read operations")
ai_agent = Agent(name="ai-reviewed", approval=AgentApproval(approver_agent=reviewer))

# Local dashboard agent
http_agent = Agent(name="dashboard", approval=HTTPApproval(port=8899))
```

---

## Registry (Advanced)

For global or centralized approval control, use the registry directly:

```python
from praisonaiagents import Agent, AutoApproveBackend
from praisonaiagents.approval import get_approval_registry

registry = get_approval_registry()

# Global auto-approve
registry.set_backend(AutoApproveBackend())

# Per-agent override via registry
registry.set_backend(AutoApproveBackend(), agent_name="trusted-bot")
```

<Note>
  The `approval=` parameter on `Agent` takes priority over the global registry.
  If an agent has `approval=True`, it will auto-approve regardless of registry settings.
</Note>

---

## Dangerous Tools (Default)

These tools require approval by default:

| Tool | Risk Level |
|------|-----------|
| `execute_command` | critical |
| `kill_process` | critical |
| `execute_code` | critical |
| `write_file` | high |
| `delete_file` | high |
| `move_file` | high |
| `execute_query` | high |
| `crawl` | medium |
| `scrape_page` | medium |

Add or remove requirements:

```python
from praisonaiagents.approval import get_approval_registry

registry = get_approval_registry()
registry.add_requirement("my_dangerous_tool", risk_level="high")
registry.remove_requirement("crawl")
```

---

## Best Practices

<AccordionGroup>
  <Accordion title="Use approval=True for bot agents">
    Set `approval=True` directly on agent constructors for unattended bots. This is the simplest, most agent-centric approach.
  </Accordion>

  <Accordion title="Use environment variable for CI/CD">
    Set `PRAISONAI_AUTO_APPROVE=true` in your CI environment to avoid blocking on prompts during automated testing.
  </Accordion>

  <Accordion title="Create custom backends for production">
    Build webhook or messaging backends that route approvals to the right team. The async protocol supports long-running approval flows.
  </Accordion>

  <Accordion title="Use per-agent backends for multi-agent systems">
    Different agents may need different approval policies. Pass different backends to each agent's `approval=` parameter.
  </Accordion>
</AccordionGroup>

---

## Related

<CardGroup cols={2}>
  <Card title="CLI Tool Approval" icon="terminal" href="/cli/tool-approval">
    `--trust`, `--approve-level`, and `--approval` CLI flags
  </Card>
  <Card title="Messaging Bots" icon="robot" href="/features/messaging-bots">
    Telegram, Discord, Slack, WhatsApp bots
  </Card>
  <Card title="Schedule Tools" icon="clock" href="/tools/schedule-tools">
    Agent-centric scheduling tools
  </Card>
  <Card title="Tools" icon="wrench" href="/tools/tools">
    Built-in tools reference
  </Card>
</CardGroup>
