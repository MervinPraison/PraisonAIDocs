---
title: "Plugins"
description: "Extend agent functionality with plugins"
icon: "puzzle-piece"
---

Plugins let you add logging, metrics, tools, and custom behavior to your agents.

```mermaid
graph TB
    subgraph "Plugin Types"
        direction LR
        TOOL["üîß Tool<br/>Provides tools"]
        HOOK["ü™ù Hook<br/>Intercepts events"]
        SKILL["‚ö° Skill<br/>Agent capabilities"]
        GUARDRAIL["üõ°Ô∏è Guardrail<br/>Validates output"]
    end
    
    TOOL --> CORE["Agent<br/>Core"]
    HOOK --> CORE
    SKILL --> CORE
    GUARDRAIL --> CORE
    
    style TOOL fill:#189AB4,color:#fff
    style HOOK fill:#189AB4,color:#fff
    style SKILL fill:#189AB4,color:#fff
    style GUARDRAIL fill:#189AB4,color:#fff
    style CORE fill:#8B0000,color:#fff
```

---

## Use Existing Plugins

The easiest way to get started - use built-in plugins:

<Tabs>
<Tab title="Python API">
```python
from praisonaiagents import Agent, plugins

# Enable built-in plugins globally
plugins.enable(["logging", "metrics"])

agent = Agent(name="Assistant", instructions="Help users")
agent.start("What's the weather?")
```
</Tab>

<Tab title="Environment Variable">
```bash
# Enable all plugins
export PRAISONAI_PLUGINS=true

# Enable specific plugins
export PRAISONAI_PLUGINS=logging,metrics
```
</Tab>

<Tab title="Config File">
Create `.praisonai/config.toml`:

```toml
[plugins]
enabled = true
auto_discover = true
directories = [
    "./.praisonai/plugins/",
    "~/.praisonai/plugins/"
]
```
</Tab>
</Tabs>

### Built-in Plugins

<AccordionGroup>
<Accordion title="LoggingPlugin" icon="file-lines">
Logs agent lifecycle events for debugging.

```python
from praisonaiagents import PluginManager
from praisonaiagents.plugins.builtin import LoggingPlugin
import logging

manager = PluginManager()
manager.register(LoggingPlugin(
    level=logging.DEBUG,  # Log level
    log_tools=True,       # Log tool calls
    log_agents=True,      # Log agent events
    log_llm=False         # Log LLM calls
))
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `level` | `int` | `INFO` | Python logging level |
| `log_tools` | `bool` | `True` | Log before/after tool calls |
| `log_agents` | `bool` | `True` | Log before/after agent runs |
| `log_llm` | `bool` | `False` | Log LLM request/response |
</Accordion>

<Accordion title="MetricsPlugin" icon="chart-bar">
Collects performance metrics.

```python
from praisonaiagents import PluginManager
from praisonaiagents.plugins.builtin import MetricsPlugin

manager = PluginManager()
metrics = MetricsPlugin()
manager.register(metrics)

# After agent runs...
data = metrics.get_metrics()
print(data)
# {
#   'uptime_seconds': 5.2,
#   'tools': {'search': {'call_count': 2, 'avg_duration_ms': 150}},
#   'agent': {'prompt_count': 1, 'response_count': 1},
#   'llm': {'call_count': 1, 'total_input_tokens': 50}
# }

metrics.reset_metrics()  # Clear all metrics
```
</Accordion>
</AccordionGroup>

---

## Hook Plugins

Intercept lifecycle events like tool calls, LLM requests, and agent start/end.

<Tabs>
<Tab title="How to Create">
```python
from praisonaiagents import Plugin, PluginInfo, PluginHook

class LoggingPlugin(Plugin):
    @property
    def info(self):
        return PluginInfo(
            name="my_logger",
            version="1.0.0",
            hooks=[PluginHook.BEFORE_TOOL, PluginHook.AFTER_TOOL]
        )
    
    def before_tool(self, tool_name, args):
        print(f"üîß Calling: {tool_name}")
        return args
    
    def after_tool(self, tool_name, result):
        print(f"‚úÖ Done: {tool_name}")
        return result
```
</Tab>

<Tab title="How to Use">
```python
from praisonaiagents import Agent, PluginManager

manager = PluginManager()
manager.register(LoggingPlugin())

agent = Agent(name="Assistant", instructions="Help users")
agent.start("Search for Python tutorials")
```

**Or use `@add_hook` decorator (simpler):**

```python
from praisonaiagents import Agent, add_hook

@add_hook('before_tool')
def log_tools(data):
    print(f"üîß Calling: {data.tool_name}")

agent = Agent(name="Assistant", instructions="Help users")
agent.start("Search for Python")
```
</Tab>

<Tab title="Single-File">
Create `~/.praisonai/plugins/my_logger.py`:

```python
"""
Plugin Name: My Logger
Description: Logs all tool calls
Version: 1.0.0
Hooks: before_tool, after_tool
"""

from praisonaiagents import add_hook

@add_hook('before_tool')
def log_before(data):
    print(f"üîß Calling: {data.tool_name}")

@add_hook('after_tool')
def log_after(data):
    print(f"‚úÖ Result: {str(data.result)[:50]}")
```

**Location:** `~/.praisonai/plugins/` (user-wide) or `./.praisonai/plugins/` (project)
</Tab>
</Tabs>

### Available Hooks

| Hook | When Called | Can Modify |
|------|-------------|------------|
| `before_agent` | Agent starts | Prompt |
| `after_agent` | Agent finishes | Response |
| `before_tool` | Tool about to run | Arguments |
| `after_tool` | Tool finished | Result |
| `before_llm` | LLM call starting | Messages, params |
| `after_llm` | LLM responded | Response |

---

## Tool Plugins

Provide additional tools that agents can use.

<Tabs>
<Tab title="How to Create">
```python
from praisonaiagents import Plugin, PluginInfo

class WeatherPlugin(Plugin):
    @property
    def info(self):
        return PluginInfo(
            name="weather",
            version="1.0.0",
            description="Weather tools"
        )
    
    def get_tools(self):
        return [{
            "name": "get_weather",
            "description": "Get weather for a city",
            "function": self._get_weather,
            "parameters": {
                "type": "object",
                "properties": {"city": {"type": "string"}},
                "required": ["city"]
            }
        }]
    
    def _get_weather(self, city: str) -> str:
        return f"‚òÄÔ∏è Sunny in {city}, 72¬∞F"
```
</Tab>

<Tab title="How to Use">
```python
from praisonaiagents import Agent, PluginManager

manager = PluginManager()
manager.register(WeatherPlugin())

# Get all tools from plugins
tools = manager.get_all_tools()

agent = Agent(
    name="Assistant",
    instructions="Help users with weather",
    tools=tools
)
agent.start("What's the weather in Paris?")
```
</Tab>

<Tab title="Single-File">
Create `~/.praisonai/plugins/weather_tools.py`:

```python
"""
Plugin Name: Weather Tools
Description: Get weather for any city
Version: 1.0.0
"""

from praisonaiagents import tool

@tool
def get_weather(city: str) -> str:
    """Get current weather for a city."""
    return f"‚òÄÔ∏è Sunny in {city}, 72¬∞F"

@tool
def get_forecast(city: str, days: int = 5) -> str:
    """Get weather forecast for a city."""
    return f"üìÖ {days}-day forecast for {city}: Mostly sunny"
```

**Location:** `~/.praisonai/plugins/` (user-wide) or `./.praisonai/plugins/` (project)

Tools are auto-discovered and available to all agents!
</Tab>
</Tabs>

---

## Guardrail Plugins

Validate agent outputs before they're returned.

<Tabs>
<Tab title="How to Create">
```python
from praisonaiagents import Plugin, PluginInfo, PluginHook

class SafetyPlugin(Plugin):
    @property
    def info(self):
        return PluginInfo(
            name="safety",
            version="1.0.0",
            hooks=[PluginHook.AFTER_AGENT]
        )
    
    def after_agent(self, response, context):
        # Block responses with sensitive content
        blocked_words = ["password", "secret", "api_key"]
        for word in blocked_words:
            if word in response.lower():
                return "[BLOCKED: Contains sensitive information]"
        return response
```
</Tab>

<Tab title="How to Use">
```python
from praisonaiagents import Agent, PluginManager

manager = PluginManager()
manager.register(SafetyPlugin())

agent = Agent(name="Assistant", instructions="Help users")
agent.start("Show me the password")
# Output: [BLOCKED: Contains sensitive information]
```
</Tab>

<Tab title="Single-File">
Create `~/.praisonai/plugins/safety_guardrail.py`:

```python
"""
Plugin Name: Safety Guardrail
Description: Blocks sensitive content
Version: 1.0.0
Hooks: after_agent
"""

from praisonaiagents import add_hook

BLOCKED_WORDS = ["password", "secret", "api_key", "token"]

@add_hook('after_agent')
def check_safety(data):
    response = str(data.result).lower()
    for word in BLOCKED_WORDS:
        if word in response:
            data.result = "[BLOCKED: Contains sensitive information]"
    return data
```

**Location:** `~/.praisonai/plugins/` (user-wide) or `./.praisonai/plugins/` (project)
</Tab>
</Tabs>

---

## LLM Plugins

Intercept and modify LLM calls for caching, logging, or token management.

<Tabs>
<Tab title="How to Create">
```python
from praisonaiagents import Plugin, PluginInfo, PluginHook

class TokenCounterPlugin(Plugin):
    def __init__(self):
        self.total_tokens = 0
    
    @property
    def info(self):
        return PluginInfo(
            name="token_counter",
            version="1.0.0",
            hooks=[PluginHook.AFTER_LLM]
        )
    
    def after_llm(self, response, usage):
        self.total_tokens += usage.get("total_tokens", 0)
        print(f"ÔøΩ Total tokens used: {self.total_tokens}")
        return response
```
</Tab>

<Tab title="How to Use">
```python
from praisonaiagents import Agent, PluginManager

counter = TokenCounterPlugin()
manager = PluginManager()
manager.register(counter)

agent = Agent(name="Assistant", instructions="Help users")
agent.start("Tell me a joke")

print(f"Session tokens: {counter.total_tokens}")
```
</Tab>

<Tab title="Single-File">
Create `~/.praisonai/plugins/token_counter.py`:

```python
"""
Plugin Name: Token Counter
Description: Counts tokens used in LLM calls
Version: 1.0.0
Hooks: after_llm
"""

from praisonaiagents import add_hook

total_tokens = 0

@add_hook('after_llm')
def count_tokens(data):
    global total_tokens
    usage = data.usage or {}
    total_tokens += usage.get("total_tokens", 0)
    print(f"üìä Total tokens: {total_tokens}")
```

**Location:** `~/.praisonai/plugins/` (user-wide) or `./.praisonai/plugins/` (project)
</Tab>
</Tabs>

---

## Plugin Locations

| Location | Scope | Auto-discovered |
|----------|-------|-----------------|
| `~/.praisonai/plugins/` | User-wide (all projects) | ‚úÖ Yes |
| `./.praisonai/plugins/` | Project-specific | ‚úÖ Yes |

```bash
# Create plugin directory
mkdir -p ~/.praisonai/plugins/

# Create a new plugin
praisonai plugins init my_plugin

# List discovered plugins
praisonai plugins list
```


---

## Lifecycle Hooks

Plugins intercept events at specific points in the agent lifecycle:


```mermaid
flowchart TB
    subgraph " "
        direction TB
        INPUT["üì• User Input"]
        
        subgraph AGENT_START["Agent Start"]
            BA["ü™ù before_agent"]
        end
        
        subgraph TOOL_CYCLE["Tool Cycle (may repeat)"]
            BT["ü™ù before_tool"]
            TOOL["üîß Tool Executes"]
            AT["ü™ù after_tool"]
        end
        
        subgraph LLM_CYCLE["LLM Call"]
            BL["ü™ù before_llm"]
            LLM["üß† LLM Generates"]
            AL["ü™ù after_llm"]
        end
        
        subgraph AGENT_END["Agent Complete"]
            AA["ü™ù after_agent"]
        end
        
        OUTPUT["üì§ Response"]
    end
    
    INPUT --> BA
    BA --> BT
    BT --> TOOL
    TOOL --> AT
    AT --> BL
    BL --> LLM
    LLM --> AL
    AL --> AA
    AA --> OUTPUT
    
    style INPUT fill:#8B0000,color:#fff
    style OUTPUT fill:#8B0000,color:#fff
    style TOOL fill:#189AB4,color:#fff
    style LLM fill:#189AB4,color:#fff
    style BA fill:#6366F1,color:#fff
    style AA fill:#6366F1,color:#fff
    style BT fill:#10B981,color:#fff
    style AT fill:#10B981,color:#fff
    style BL fill:#F59E0B,color:#fff
    style AL fill:#F59E0B,color:#fff
```

| Hook | Stage | Can Modify |
|------|-------|------------|
| `before_agent` | Agent starts | Prompt, context |
| `before_tool` | Tool about to run | Tool arguments |
| `after_tool` | Tool finished | Tool result |
| `before_llm` | LLM call starting | Messages, params |
| `after_llm` | LLM responded | LLM response |
| `after_agent` | Agent finishing | Final response |

---

## Protocols

Type-safe plugin interfaces using Python protocols.

```mermaid
graph TB
    subgraph "Plugin Protocols"
        PP["üîå PluginProtocol<br/>(base)"]
        
        PP --> TP["üîß ToolPluginProtocol<br/>get_tools()"]
        PP --> HP["ü™ù HookPluginProtocol<br/>before_*/after_*"]
        PP --> AP["ü§ñ AgentPluginProtocol<br/>before_agent/after_agent"]
        PP --> LP["üß† LLMPluginProtocol<br/>before_llm/after_llm"]
    end
    
    style PP fill:#8B0000,color:#fff
    style TP fill:#189AB4,color:#fff
    style HP fill:#10B981,color:#fff
    style AP fill:#6366F1,color:#fff
    style LP fill:#F59E0B,color:#fff
```

| Protocol | Purpose | Key Methods |
|----------|---------|-------------|
| `PluginProtocol` | Base plugin | `name`, `version`, `on_init`, `on_shutdown` |
| `ToolPluginProtocol` | Provides tools | `get_tools()` |
| `HookPluginProtocol` | Intercepts events | `before_tool`, `after_tool`, etc. |
| `AgentPluginProtocol` | Agent lifecycle | `before_agent`, `after_agent` |
| `LLMPluginProtocol` | LLM calls | `before_llm`, `after_llm` |

```python
from praisonaiagents import (
    PluginProtocol,
    ToolPluginProtocol,
    HookPluginProtocol,
    AgentPluginProtocol,
    LLMPluginProtocol
)

# Check if object implements protocol
if isinstance(my_plugin, PluginProtocol):
    print("Valid plugin!")

# Implement specific protocol
class MyToolPlugin:
    @property
    def name(self) -> str:
        return "tool_provider"
    
    @property
    def version(self) -> str:
        return "1.0.0"
    
    def on_init(self, context):
        pass
    
    def on_shutdown(self):
        pass
    
    def get_tools(self):
        return [{"name": "my_tool", "description": "Does something"}]

# Type checker validates implementation
assert isinstance(MyToolPlugin(), ToolPluginProtocol)
```

## Available Hooks

```mermaid
graph TB
    subgraph "Plugin Hook Categories"
        A[üîß Lifecycle] --> A1[ON_INIT]
        A --> A2[ON_SHUTDOWN]
        A --> A3[SETUP]
        
        B[ü§ñ Agent] --> B1[BEFORE_AGENT]
        B --> B2[AFTER_AGENT]
        B --> B3[SUBAGENT_STOP]
        
        C[üõ†Ô∏è Tool] --> C1[BEFORE_TOOL]
        C --> C2[AFTER_TOOL]
        
        D[üß† LLM] --> D1[BEFORE_LLM]
        D --> D2[AFTER_LLM]
        
        E[üí¨ User] --> E1[USER_PROMPT_SUBMIT]
        E --> E2[NOTIFICATION]
    end
    
    classDef lifecycle fill:#6366F1,stroke:#7C90A0,color:#fff
    classDef agent fill:#8B0000,stroke:#7C90A0,color:#fff
    classDef tool fill:#189AB4,stroke:#7C90A0,color:#fff
    classDef llm fill:#F59E0B,stroke:#7C90A0,color:#fff
    classDef user fill:#10B981,stroke:#7C90A0,color:#fff
    
    class A,A1,A2,A3 lifecycle
    class B,B1,B2,B3 agent
    class C,C1,C2 tool
    class D,D1,D2 llm
    class E,E1,E2 user
```

### Core Hooks

| Hook | When Called | Can Modify |
|------|-------------|------------|
| `ON_INIT` | Plugin initialization | Context |
| `ON_SHUTDOWN` | Plugin shutdown | - |
| `BEFORE_AGENT` | Before agent execution | Prompt |
| `AFTER_AGENT` | After agent execution | Response |
| `BEFORE_TOOL` | Before tool call | Arguments |
| `AFTER_TOOL` | After tool call | Result |
| `BEFORE_LLM` | Before LLM call | Messages, Params |
| `AFTER_LLM` | After LLM response | Response |
| `ON_PERMISSION_ASK` | Permission requested | Approval |
| `ON_CONFIG` | Configuration loaded | Config |
| `ON_AUTH` | Authentication needed | Credentials |

### Extended Hooks

| Hook | When Called | Can Modify |
|------|-------------|------------|
| `USER_PROMPT_SUBMIT` | User submits prompt | Input |
| `NOTIFICATION` | Notification sent | Message |
| `SUBAGENT_STOP` | Subagent completes | Result |
| `SETUP` | System initialization | Config |
| `BEFORE_MESSAGE` | Before message processed | Message |
| `AFTER_MESSAGE` | After message processed | Message |
| `MESSAGE_RECEIVED` | Message received | Message |
| `MESSAGE_SENDING` | Before message sent | Message |
| `MESSAGE_SENT` | After message sent | - |
| `SESSION_START` | Session begins | Context |
| `SESSION_END` | Session ends | - |
| `BEFORE_COMPACTION` | Before context compaction | Context |
| `AFTER_COMPACTION` | After context compaction | Context |
| `TOOL_RESULT_PERSIST` | Before tool result stored | Result |
| `ON_ERROR` | Error occurred | Error handling |
| `ON_RETRY` | Retry attempted | Retry config |
| `GATEWAY_START` | Gateway starts | Config |
| `GATEWAY_STOP` | Gateway stops | - |

## Single-File Plugins

Create plugins as simple Python files with WordPress-style headers. This is the **simplest** way to create plugins.

```mermaid
flowchart LR
    subgraph SingleFile["Single-File Plugin"]
        A["üìÑ plugin.py"] --> B["üìã Header"]
        B --> C["üîß @tool"]
        B --> D["ü™ù @add_hook"]
    end
    
    style A fill:#6366F1,stroke:#7C90A0,color:#fff
    style B fill:#F59E0B,stroke:#7C90A0,color:#fff
    style C fill:#10B981,stroke:#7C90A0,color:#fff
    style D fill:#10B981,stroke:#7C90A0,color:#fff
```

### Plugin Header Format

```python
"""
Plugin Name: Weather Tools
Description: Get weather information for any location
Version: 1.0.0
Author: Your Name
Hooks: before_tool, after_tool
Dependencies: requests
"""

from praisonaiagents import tool

@tool
def get_weather(location: str) -> str:
    """Get current weather for a location."""
    return f"Weather for {location}: Sunny, 72¬∞F"
```

### CLI Commands

Manage single-file plugins from the command line:

<Tabs>
  <Tab title="Create Plugin">
```bash
# Create a new plugin with template
praisonai plugins init my_plugin

# With options
praisonai plugins init weather_tools --author "John Doe" --with-hook

# In a specific directory
praisonai plugins init custom --output ./my_plugins/
```
  </Tab>
  <Tab title="List & Scan">
```bash
# List all discovered plugins
praisonai plugins scan

# With details
praisonai plugins scan --verbose

# JSON output
praisonai plugins scan --json
```
  </Tab>
  <Tab title="Load & Discover">
```bash
# Load a specific plugin file
praisonai plugins load ./my_plugin.py

# Discover and load all plugins
praisonai plugins discover --verbose
```
  </Tab>
  <Tab title="Template">
```bash
# Print a plugin template to stdout
praisonai plugins template

# Save to file
praisonai plugins template > my_plugin.py

# With hook example
praisonai plugins template --with-hook
```
  </Tab>
</Tabs>

### Discovery and Loading

```python
from praisonaiagents import (
    discover_plugins,
    load_plugin,
    discover_and_load_plugins,
    get_default_plugin_dirs,
)

# Discover plugins without loading
plugins = discover_plugins()
for p in plugins:
    print(f"{p['name']} v{p['version']}")

# Load a specific plugin
metadata = load_plugin("./plugins/weather.py")
print(f"Loaded: {metadata['name']}")

# Discover and load all plugins at once
all_plugins = discover_and_load_plugins()

# Get default plugin directories
# Returns: ['./.praisonai/plugins/', '~/.praisonai/plugins/']
dirs = get_default_plugin_dirs()
```

### Plugin Directories

Plugins are discovered from these directories (in precedence order):

| Directory | Scope |
|-----------|-------|
| `./.praisonai/plugins/` | Project-specific |
| `~/.praisonai/plugins/` | User-wide |

### Generate Plugin Template

```python
from praisonaiagents import get_plugin_template, ensure_plugin_dir

# Generate a plugin template
template = get_plugin_template(
    name="My Plugin",
    description="Does something useful",
    author="Your Name"
)

# Ensure user plugin directory exists
plugin_dir = ensure_plugin_dir()  # Creates ~/.praisonai/plugins/
```

---

## Folder Structure

```
praisonaiagents/plugins/
‚îú‚îÄ‚îÄ __init__.py           # Public exports
‚îú‚îÄ‚îÄ protocols.py          # Plugin protocols
‚îú‚îÄ‚îÄ manager.py            # PluginManager
‚îú‚îÄ‚îÄ plugin.py             # Plugin base class
‚îú‚îÄ‚îÄ parser.py             # Single-file header parser
‚îú‚îÄ‚îÄ discovery.py          # Plugin discovery
‚îú‚îÄ‚îÄ sdk/                  # Plugin SDK
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ decorators.py
‚îî‚îÄ‚îÄ builtin/              # Built-in plugins
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ logging_plugin.py
    ‚îî‚îÄ‚îÄ metrics_plugin.py
```

## Examples

<Tabs>
  <Tab title="Function Plugin">
```python
from praisonaiagents import PluginManager, FunctionPlugin, PluginHook

def log_tool_calls(tool_name, args):
    print(f"Tool: {tool_name}, Args: {args}")
    return args

plugin = FunctionPlugin(
    name="logger",
    hooks={PluginHook.BEFORE_TOOL: log_tool_calls}
)

manager = PluginManager()
manager.register(plugin)
```
  </Tab>
  <Tab title="Directory Loading">
```python
# plugins/my_plugin.py
from praisonaiagents import Plugin, PluginInfo

class MyPlugin(Plugin):
    @property
    def info(self):
        return PluginInfo(name="my_plugin")

# main.py
from praisonaiagents import PluginManager

manager = PluginManager()
count = manager.load_from_directory("./plugins")
print(f"Loaded {count} plugins")
```
  </Tab>
  <Tab title="Tool Provider">
```python
from praisonaiagents import Plugin, PluginInfo, PluginManager

class CalculatorPlugin(Plugin):
    @property
    def info(self):
        return PluginInfo(name="calculator")
    
    def get_tools(self):
        return [{
            "name": "calculate",
            "description": "Perform math calculations",
            "function": lambda expr: eval(expr),
            "parameters": {
                "type": "object",
                "properties": {"expr": {"type": "string"}}
            }
        }]

manager = PluginManager()
manager.register(CalculatorPlugin())
tools = manager.get_all_tools()
```
  </Tab>
</Tabs>

## Performance

<Note>
Plugins use lazy loading and have zero overhead when not used. All imports are deferred until the plugin is actually accessed.
</Note>

```python
# This import is instant - no plugins loaded yet
from praisonaiagents.plugins import PluginManager

# Plugins only load when registered
manager = PluginManager()
manager.register(LoggingPlugin())  # LoggingPlugin loads here
```
