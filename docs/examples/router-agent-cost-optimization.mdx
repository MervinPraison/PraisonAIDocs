---
title: Router Agent Cost Optimization Examples
description: Learn how to use Router Agents to optimize costs across multiple AI providers
---

# Router Agent Cost Optimization Examples

The Router Agent in PraisonAI enables intelligent model selection based on task complexity and cost constraints, helping you optimize AI costs while maintaining quality.

## Overview

Router Agents automatically analyze task requirements and select the most cost-effective model that can handle the task successfully. This can lead to significant cost savings, especially for applications with varying complexity levels.

## Basic Router Agent Setup

```python
from praisonaiagents import RouterAgent

# Create a router agent with cost optimization
router_agent = RouterAgent(
    name="Cost Optimizer",
    instructions="Analyze tasks and route to the most cost-effective model",
    routing_strategy="cost-optimized",
    cost_threshold=0.01,  # Maximum $0.01 per 1k tokens
    preferred_providers=["openai", "groq"],  # Prioritize these providers
    fallback_model="openai/gpt-4o-mini",
    verbose=True
)

# The router will automatically select models based on task complexity
response = router_agent.start("What is 2+2?")  # Uses cheapest model (e.g., gpt-4o-mini)
response = router_agent.start("Write a complex business strategy")  # Uses more capable model
```

## Model Cost Profiles

PraisonAI includes pre-configured cost profiles for popular models:

| Model | Cost per 1k tokens | Best For |
|-------|-------------------|----------|
| Gemini 1.5 Flash | $0.000125 | Simple tasks, high volume |
| GPT-4o-mini | $0.00075 | General tasks, good balance |
| DeepSeek Chat | $0.0014 | Code and math tasks |
| GPT-4o | $0.0075 | Complex reasoning |
| Claude 3.5 Sonnet | $0.009 | Creative and analysis |
| Claude 3 Opus | $0.045 | Most complex tasks |

## Advanced Cost Optimization Strategies

### 1. Automatic Task Complexity Analysis

```python
from praisonaiagents import RouterAgent

# Router with automatic complexity detection
router = RouterAgent(
    name="Smart Router",
    routing_strategy="auto",
    models=[
        "gemini/gemini-1.5-flash",    # For simple tasks
        "openai/gpt-4o-mini",          # For moderate tasks
        "openai/gpt-4o",               # For complex tasks
        "anthropic/claude-3-5-sonnet", # For very complex tasks
    ],
    verbose=True
)

# Examples of automatic routing
router.start("Define the word 'hello'")  # Routes to Gemini Flash
router.start("Summarize this article about quantum computing...")  # Routes to GPT-4o-mini
router.start("Design a microservices architecture for...")  # Routes to GPT-4o or Claude
```

### 2. Budget-Conscious Routing

```python
from praisonaiagents import RouterAgent, Task

# Set strict cost limits
budget_router = RouterAgent(
    name="Budget Router",
    routing_strategy="cost-optimized",
    cost_threshold=0.001,  # Very low threshold - $0.001 per 1k tokens
    preferred_providers=["groq", "gemini"],  # Prefer cheaper providers
    fallback_model="groq/llama-3.3-70b-versatile"
)

# Process multiple tasks within budget
tasks = [
    Task(description="Calculate monthly revenue", expected_output="number"),
    Task(description="Generate product description", expected_output="text"),
    Task(description="Analyze customer feedback", expected_output="insights")
]

for task in tasks:
    response = budget_router.start(task)
    print(f"Task completed with model: {budget_router.last_model_used}")
    print(f"Estimated cost: ${budget_router.estimate_cost(task)}")
```

### 3. Tiered Model Selection

```python
from praisonaiagents import RouterAgent, AutoAgents

# Create a tiered system for different user types
def create_tiered_router(user_tier):
    tiers = {
        "free": {
            "cost_threshold": 0.0005,
            "models": ["groq/llama-3.3-70b-versatile", "gemini/gemini-1.5-flash"]
        },
        "pro": {
            "cost_threshold": 0.005,
            "models": ["openai/gpt-4o-mini", "openai/gpt-4o", "gemini/gemini-1.5-pro"]
        },
        "enterprise": {
            "cost_threshold": 0.05,
            "models": ["openai/gpt-4o", "anthropic/claude-3-5-sonnet", "anthropic/claude-3-opus"]
        }
    }
    
    tier_config = tiers.get(user_tier, tiers["free"])
    
    return RouterAgent(
        name=f"{user_tier.title()} Router",
        routing_strategy="cost-optimized",
        cost_threshold=tier_config["cost_threshold"],
        models=tier_config["models"]
    )

# Usage
free_router = create_tiered_router("free")
enterprise_router = create_tiered_router("enterprise")
```

## Integration with AutoAgents

Router Agents work seamlessly with AutoAgents for workflow optimization:

```python
from praisonaiagents import AutoAgents, RouterAgent

# Create a cost-optimized workflow
router = RouterAgent(
    routing_strategy="cost-optimized",
    cost_threshold=0.003
)

agents = AutoAgents(
    instructions="Create a market analysis report",
    router_agent=router,  # All agents will use cost-optimized routing
    verbose=True
)

# The workflow will automatically use cheaper models for simple sub-tasks
# and more expensive models only when necessary
agents.start()

# View cost breakdown
print(f"Total estimated cost: ${agents.get_total_cost()}")
print(f"Cost by model: {agents.get_cost_breakdown()}")
```

## Monitoring and Reporting

### Usage Tracking

```python
from praisonaiagents import RouterAgent
import json

# Router with usage tracking
router = RouterAgent(
    name="Tracked Router",
    routing_strategy="cost-optimized",
    enable_usage_tracking=True
)

# Process multiple requests
responses = []
for i in range(10):
    response = router.start(f"Task {i}: Analyze this data...")
    responses.append(response)

# Get usage report
usage_report = router.get_usage_report()
print(json.dumps(usage_report, indent=2))
# Output:
# {
#   "total_calls": 10,
#   "total_tokens": 5432,
#   "total_cost": 0.0234,
#   "by_model": {
#     "openai/gpt-4o-mini": {"calls": 7, "tokens": 3200, "cost": 0.0024},
#     "openai/gpt-4o": {"calls": 3, "tokens": 2232, "cost": 0.021}
#   }
# }
```

### Cost Alerts

```python
from praisonaiagents import RouterAgent, Agent

# Router with cost alerts
def cost_alert_callback(model, estimated_cost, task):
    if estimated_cost > 0.01:
        print(f"⚠️ High cost alert: {model} will cost ${estimated_cost:.4f} for this task")
        return input("Continue? (y/n): ").lower() == 'y'
    return True

router = RouterAgent(
    routing_strategy="auto",
    cost_alert_callback=cost_alert_callback
)
```

## Best Practices

### 1. Start with Conservative Thresholds
Begin with lower cost thresholds and gradually increase based on quality requirements:

```python
# Development
dev_router = RouterAgent(cost_threshold=0.001)

# Staging
staging_router = RouterAgent(cost_threshold=0.005)

# Production
prod_router = RouterAgent(cost_threshold=0.01)
```

### 2. Use Fallback Models
Always configure fallback models to ensure reliability:

```python
router = RouterAgent(
    routing_strategy="cost-optimized",
    cost_threshold=0.002,
    fallback_model="openai/gpt-4o-mini",  # Reliable fallback
    fallback_on_error=True
)
```

### 3. Monitor and Optimize
Regularly review usage patterns and adjust routing strategies:

```python
# Weekly optimization review
def optimize_routing(router, usage_data):
    # Analyze which tasks could use cheaper models
    for task_type, stats in usage_data.items():
        if stats["success_rate"] > 0.95 and stats["avg_cost"] > 0.005:
            print(f"Consider using cheaper models for {task_type}")
    
    # Adjust thresholds based on budget utilization
    if usage_data["total_cost"] < usage_data["budget"] * 0.5:
        router.cost_threshold *= 1.2  # Increase threshold if under budget
```

## Real-World Cost Savings Example

Here's an example showing potential cost savings for a customer service application:

```python
from praisonaiagents import RouterAgent, Agent
import datetime

# Traditional approach - using GPT-4 for everything
traditional_agent = Agent(
    instructions="Handle customer inquiries",
    model="openai/gpt-4o"
)

# Optimized approach - using RouterAgent
optimized_agent = RouterAgent(
    instructions="Handle customer inquiries efficiently",
    routing_strategy="cost-optimized",
    cost_threshold=0.005
)

# Simulate daily workload
inquiries = [
    "What are your business hours?",  # Simple
    "How do I reset my password?",     # Simple
    "Explain your refund policy",      # Moderate
    "I have a complex billing issue...", # Complex
    "Where is my order?",              # Simple
]

# Calculate costs
traditional_cost = len(inquiries) * 0.0075  # GPT-4 for all
optimized_cost = 0.000125 * 3 + 0.00075 * 1 + 0.0075 * 1  # Mixed models

print(f"Traditional approach: ${traditional_cost:.4f}/day")
print(f"Optimized approach: ${optimized_cost:.4f}/day")
print(f"Savings: ${(traditional_cost - optimized_cost) * 365:.2f}/year")
# Output:
# Traditional approach: $0.0375/day
# Optimized approach: $0.0086/day
# Savings: $10.55/year (per 5 queries/day)
```

## Conclusion

Router Agents provide powerful cost optimization capabilities while maintaining response quality. By implementing intelligent routing strategies, you can achieve significant cost savings, especially for applications with varying task complexity. Start with the basic setup and gradually implement more sophisticated strategies as you understand your usage patterns.

## Next Steps

- Explore [Multi-Provider Examples](./multi-provider-switching.mdx) for failover strategies
- Learn about [Session Persistence](./session-persistence.mdx) for stateful cost tracking
- Check out [Quality-Based RAG](./quality-based-rag.mdx) for optimizing retrieval costs