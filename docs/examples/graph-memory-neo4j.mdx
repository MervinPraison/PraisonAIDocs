---
title: Graph Memory with Neo4j Examples
description: Learn how to implement graph-based memory using Neo4j for relationship-aware AI agents
---

# Graph Memory with Neo4j Examples

Graph memory in PraisonAI enables agents to store and retrieve information using graph databases like Neo4j, allowing for sophisticated relationship modeling and traversal that goes beyond traditional vector-based memory.

## Overview

Graph memory is particularly powerful for:
- Modeling complex relationships between entities
- Maintaining conversation context with relationship awareness
- Building knowledge graphs from agent interactions
- Combining graph traversal with vector similarity search

## Basic Neo4j Setup

### Docker Setup for Local Development

```bash
# Run Neo4j using Docker
docker run -d \
  --name neo4j \
  -p 7474:7474 -p 7687:7687 \
  -e NEO4J_AUTH=neo4j/your-password \
  -e NEO4J_PLUGINS='["apoc"]' \
  neo4j:latest

# Access Neo4j browser at http://localhost:7474
```

### Cloud Setup with Neo4j AuraDB

```python
# Neo4j AuraDB configuration
graph_config = {
    "provider": "mem0",
    "config": {
        "graph_store": {
            "provider": "neo4j",
            "config": {
                "url": "neo4j+s://your-instance.databases.neo4j.io",
                "username": "neo4j",
                "password": "your-aura-password"
            }
        }
    }
}
```

## Graph Memory Agent Examples

### 1. Basic Graph Memory Agent

```python
from praisonaiagents import Agent

# Create an agent with Neo4j graph memory
agent = Agent(
    name="Knowledge Graph Agent",
    instructions="You help users by remembering relationships between concepts",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "neo4j",
                "config": {
                    "url": "bolt://localhost:7687",
                    "username": "neo4j",
                    "password": "your-password"
                }
            },
            "vector_store": {
                "provider": "chroma",
                "config": {
                    "collection_name": "agent_memory",
                    "path": "./chroma_db"
                }
            },
            "version": "v1.1"
        }
    }
)

# The agent will automatically extract and store relationships
response = agent.start("""
John is the CEO of TechCorp. 
Sarah reports to John and manages the Engineering team.
The Engineering team is working on Project Alpha.
""")

# Query relationships
response = agent.start("Who manages the Engineering team?")
print(response)  # Sarah manages the Engineering team

response = agent.start("What is the Engineering team working on?")
print(response)  # The Engineering team is working on Project Alpha
```

### 2. Advanced Entity Relationship Modeling

```python
from praisonaiagents import Agent, Memory

# Create memory with custom entity extraction
memory = Memory(
    provider="mem0",
    config={
        "graph_store": {
            "provider": "neo4j",
            "config": {
                "url": "bolt://localhost:7687",
                "username": "neo4j",
                "password": "your-password"
            }
        },
        "custom_prompt": """
        Extract entities and relationships in this format:
        Entities: [type:name, ...]
        Relationships: [entity1 -[relationship]-> entity2, ...]
        """
    }
)

# Research assistant with graph memory
research_agent = Agent(
    name="Research Assistant",
    instructions="You help analyze research papers and their connections",
    memory=memory
)

# Process research information
research_agent.start("""
Dr. Alice Smith from MIT published a paper on quantum computing in 2024.
Her work builds upon Dr. Bob Johnson's 2023 research at Stanford.
Both papers cite the fundamental work by Dr. Carol White from 2020.
The MIT paper was funded by the NSF grant #12345.
""")

# Query the knowledge graph
print(research_agent.start("What papers influenced Dr. Smith's work?"))
print(research_agent.start("Which institutions are involved in quantum computing research?"))
print(research_agent.start("Show me the citation network"))
```

### 3. Multi-Agent System with Shared Graph Memory

```python
from praisonaiagents import Agent

# Shared graph memory configuration
shared_memory_config = {
    "provider": "mem0",
    "config": {
        "graph_store": {
            "provider": "neo4j",
            "config": {
                "url": "bolt://localhost:7687",
                "username": "neo4j",
                "password": "your-password",
                "database": "shared_knowledge"  # Shared database
            }
        }
    }
}

# Create multiple agents sharing the same graph
analyst = Agent(
    name="Data Analyst",
    instructions="You analyze data and identify patterns",
    memory=shared_memory_config
)

researcher = Agent(
    name="Researcher",
    instructions="You research topics and find connections",
    memory=shared_memory_config
)

writer = Agent(
    name="Writer",
    instructions="You create reports based on analysis and research",
    memory=shared_memory_config
)

# Agents build on each other's knowledge
analyst.start("Sales increased 25% in Q4 2024, mainly driven by Product A in North America")
researcher.start("Product A's success correlates with the marketing campaign launched in October")
report = writer.start("Write a summary of Q4 performance")
```

## Hybrid Graph and Vector Search

### Combining Graph Traversal with Semantic Search

```python
from praisonaiagents import Agent

# Hybrid memory configuration
hybrid_agent = Agent(
    name="Hybrid Search Agent",
    instructions="You combine relationship understanding with semantic search",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "neo4j",
                "config": {
                    "url": "bolt://localhost:7687",
                    "username": "neo4j",
                    "password": "your-password"
                }
            },
            "vector_store": {
                "provider": "qdrant",
                "config": {
                    "collection_name": "hybrid_memory",
                    "embedding_model": "text-embedding-ada-002"
                }
            },
            "enable_hybrid_search": True,
            "search_strategy": "graph_first"  # or "vector_first", "balanced"
        }
    }
)

# Add complex information
hybrid_agent.start("""
The customer journey begins with awareness through social media.
Awareness leads to consideration, where users compare products.
During consideration, 65% of users read reviews.
Positive reviews increase conversion probability by 40%.
After purchase, satisfied customers often become brand advocates.
Brand advocates generate 3x more referrals than regular customers.
""")

# Hybrid queries
response = hybrid_agent.start(
    "How do reviews impact the sales funnel?",
    search_config={
        "use_graph": True,      # Traverse relationships
        "use_vector": True,     # Semantic similarity
        "graph_depth": 2,       # How many hops in the graph
        "vector_top_k": 5       # Number of similar memories
    }
)
```

## Advanced Graph Patterns

### 1. Temporal Graph Memory

```python
from praisonaiagents import Agent
import datetime

# Agent with temporal graph memory
temporal_agent = Agent(
    name="Timeline Tracker",
    instructions="You track events and their temporal relationships",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "neo4j",
                "config": {
                    "url": "bolt://localhost:7687",
                    "username": "neo4j",
                    "password": "your-password"
                },
                "enable_timestamps": True,
                "relationship_properties": ["timestamp", "duration", "sequence"]
            }
        }
    }
)

# Track project timeline
temporal_agent.start("""
Project kickoff happened on January 15, 2024.
Requirements gathering took 2 weeks after kickoff.
Development started immediately after requirements and lasted 3 months.
Testing began in parallel with the last month of development.
""")

# Query temporal relationships
print(temporal_agent.start("What was happening in February 2024?"))
print(temporal_agent.start("Show me the project timeline"))
```

### 2. Hierarchical Knowledge Graphs

```python
from praisonaiagents import Agent

# Organization hierarchy agent
hierarchy_agent = Agent(
    name="Org Chart Manager",
    instructions="You manage organizational hierarchies and reporting structures",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "neo4j",
                "config": {
                    "url": "bolt://localhost:7687",
                    "username": "neo4j",
                    "password": "your-password"
                },
                "hierarchical_relationships": ["manages", "reports_to", "part_of"],
                "transitive_closure": True  # Automatically compute indirect relationships
            }
        }
    }
)

# Build organizational knowledge
hierarchy_agent.start("""
Alice is the CEO.
Bob and Carol are VPs reporting to Alice.
Bob manages the Engineering division with teams: Backend, Frontend, and DevOps.
Carol manages the Business division with teams: Sales, Marketing, and Support.
David leads the Backend team under Bob.
Eve leads the Sales team under Carol.
""")

# Query hierarchical relationships
print(hierarchy_agent.start("Who are all the people under Bob's organization?"))
print(hierarchy_agent.start("What is the reporting chain from David to the CEO?"))
```

### 3. Graph Analytics and Insights

```python
from praisonaiagents import Agent

# Analytics-enabled graph agent
analytics_agent = Agent(
    name="Graph Analyst",
    instructions="You analyze network patterns and provide insights",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "neo4j",
                "config": {
                    "url": "bolt://localhost:7687",
                    "username": "neo4j",
                    "password": "your-password"
                },
                "enable_analytics": True,
                "analytics_algorithms": ["pagerank", "community_detection", "centrality"]
            }
        }
    }
)

# Build a knowledge network
analytics_agent.start("""
In the AI research community:
- Yoshua Bengio collaborates with Ian Goodfellow and Aaron Courville
- Geoffrey Hinton works with Yann LeCun and Andrew Ng
- Andrew Ng collaborates with Fei-Fei Li and Christopher Manning
- Yann LeCun works with Yoshua Bengio on several projects
- Ian Goodfellow's GAN work influenced many researchers including Jun-Yan Zhu
""")

# Analyze the network
print(analytics_agent.start("Who are the most influential researchers in this network?"))
print(analytics_agent.start("Identify research communities or clusters"))
print(analytics_agent.start("Find the shortest collaboration path between Hinton and Fei-Fei Li"))
```

## Memgraph Alternative

```python
from praisonaiagents import Agent

# Using Memgraph instead of Neo4j
memgraph_agent = Agent(
    name="Memgraph Agent",
    instructions="You use Memgraph for high-performance graph operations",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "memgraph",  # Use Memgraph
                "config": {
                    "host": "localhost",
                    "port": 7687,
                    "username": "memgraph",
                    "password": "your-password",
                    "encrypted": False
                }
            }
        }
    }
)

# Memgraph excels at real-time graph analytics
memgraph_agent.start("Track real-time social network interactions...")
```

## Performance Optimization

### 1. Index Configuration

```python
# Optimize graph queries with indexes
memory_config = {
    "provider": "mem0",
    "config": {
        "graph_store": {
            "provider": "neo4j",
            "config": {
                "url": "bolt://localhost:7687",
                "username": "neo4j",
                "password": "your-password"
            },
            "indexes": [
                {"label": "Person", "property": "name"},
                {"label": "Document", "property": "title"},
                {"label": "Concept", "property": "name"}
            ],
            "constraints": [
                {"label": "Person", "property": "email", "type": "unique"}
            ]
        }
    }
}
```

### 2. Batch Operations

```python
from praisonaiagents import Agent, Memory

# Batch import for better performance
memory = Memory(
    provider="mem0",
    config={
        "graph_store": {
            "provider": "neo4j",
            "config": {
                "url": "bolt://localhost:7687",
                "username": "neo4j",
                "password": "your-password"
            },
            "batch_size": 1000,  # Process in batches
            "use_transactions": True
        }
    }
)

# Bulk import knowledge
agent = Agent(name="Bulk Importer", memory=memory)
agent.bulk_add_memories(knowledge_base)  # Large dataset
```

## Troubleshooting

### Common Issues and Solutions

1. **Connection Issues**
```python
# Check Neo4j connection
from neo4j import GraphDatabase

uri = "bolt://localhost:7687"
driver = GraphDatabase.driver(uri, auth=("neo4j", "password"))

try:
    driver.verify_connectivity()
    print("Connected successfully!")
except Exception as e:
    print(f"Connection failed: {e}")
finally:
    driver.close()
```

2. **Memory Debugging**
```python
# Enable debug mode
agent = Agent(
    name="Debug Agent",
    memory={
        "provider": "mem0",
        "config": {
            "graph_store": {
                "provider": "neo4j",
                "config": {...},
                "debug": True,  # Enable query logging
                "log_queries": True
            }
        }
    }
)
```

## Best Practices

1. **Design Your Graph Schema**
   - Plan entity types and relationships before implementation
   - Use meaningful relationship names (e.g., "MANAGES", "REPORTS_TO")
   - Add properties to relationships when needed

2. **Optimize for Your Use Case**
   - Use graph memory for relationship-heavy data
   - Combine with vector search for hybrid capabilities
   - Index frequently queried properties

3. **Monitor Performance**
   - Track query execution times
   - Monitor memory usage
   - Use Neo4j's query profiler for optimization

## Conclusion

Graph memory with Neo4j provides powerful capabilities for building relationship-aware AI agents. By modeling data as graphs, agents can understand complex relationships, traverse connections, and provide more contextual responses. The combination of graph and vector search enables sophisticated memory systems that excel at both relationship understanding and semantic similarity.

## Next Steps

- Explore [Approval System Examples](./approval-system-human-loop.mdx) for human oversight
- Learn about [Session Persistence](./session-persistence.mdx) for stateful graph applications
- Check out [Quality-Based RAG](./quality-based-rag.mdx) for enhanced retrieval