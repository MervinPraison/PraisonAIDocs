---
title: Approval System and Human-in-the-Loop Examples
description: Learn how to implement human oversight and approval workflows in AI agent systems
---

# Approval System and Human-in-the-Loop Examples

The approval system in PraisonAI enables human oversight of agent actions, ensuring safety and control over critical operations. This guide demonstrates various human-in-the-loop patterns for building trustworthy AI systems.

## Overview

Human-in-the-loop patterns are essential for:
- Preventing unauthorized or dangerous actions
- Maintaining human control over critical decisions
- Building trust through transparency
- Meeting compliance and regulatory requirements
- Enabling smooth AI-to-human handoffs

## Basic Approval System

### Simple Tool Approval

```python
from praisonaiagents import Agent, tool, require_approval

# Create a tool that requires approval
@tool
@require_approval(risk_level="high")
def delete_customer_data(customer_id: str) -> str:
    """Delete all data for a customer - requires approval"""
    # Actual deletion logic here
    return f"Customer {customer_id} data deleted"

# Agent with approval-required tools
agent = Agent(
    name="Data Manager",
    instructions="You help manage customer data with appropriate oversight",
    tools=[delete_customer_data]
)

# When the agent tries to use the tool, it will prompt for approval
response = agent.start("Delete customer data for ID 12345")
# Console output:
# ‚ö†Ô∏è  Approval required for delete_customer_data
# Risk level: high
# Arguments: {'customer_id': '12345'}
# Approve? (yes/no/modify):
```

### Risk-Based Approval Levels

```python
from praisonaiagents import Agent, tool, require_approval

# Different risk levels for different operations
@tool
@require_approval(risk_level="critical")
def execute_database_query(query: str) -> str:
    """Execute raw SQL query - requires critical approval"""
    # Query execution logic
    return "Query executed"

@tool
@require_approval(risk_level="high")
def modify_user_permissions(user_id: str, permissions: list) -> str:
    """Modify user permissions - requires high-level approval"""
    return f"Permissions updated for user {user_id}"

@tool
@require_approval(risk_level="medium")
def export_data(dataset: str, format: str) -> str:
    """Export data - requires medium-level approval"""
    return f"Data exported to {format}"

@tool
@require_approval(risk_level="low")
def send_notification(user_id: str, message: str) -> str:
    """Send notification - requires low-level approval"""
    return "Notification sent"

# Configure approval callbacks based on risk
def approval_callback(tool_name, args, risk_level):
    if risk_level == "low":
        # Auto-approve low risk operations
        print(f"Auto-approving {tool_name}")
        return {"approved": True}
    elif risk_level == "medium":
        # Log and approve medium risk
        print(f"Logging operation: {tool_name} with args {args}")
        return {"approved": True}
    else:
        # Require manual approval for high/critical
        response = input(f"Approve {tool_name}? (y/n): ")
        return {"approved": response.lower() == 'y'}

agent = Agent(
    name="Risk-Aware Agent",
    tools=[execute_database_query, modify_user_permissions, export_data, send_notification],
    approval_callback=approval_callback
)
```

## Advanced Approval Patterns

### 1. Custom Approval Callbacks with Logging

```python
from praisonaiagents import Agent, tool, require_approval
import json
import datetime
import logging

# Set up audit logging
logging.basicConfig(filename='approvals.log', level=logging.INFO)

class ApprovalSystem:
    def __init__(self):
        self.approval_history = []
        self.policies = {
            "max_daily_deletions": 10,
            "require_two_factor": ["delete", "modify"],
            "business_hours_only": ["export", "modify"]
        }
    
    def check_policies(self, tool_name, args):
        # Check business hours
        current_hour = datetime.datetime.now().hour
        if any(word in tool_name for word in self.policies["business_hours_only"]):
            if current_hour < 9 or current_hour > 17:
                return False, "Operation only allowed during business hours"
        
        # Check daily limits
        today_deletions = sum(1 for record in self.approval_history 
                            if "delete" in record["tool"] 
                            and record["date"] == str(datetime.date.today()))
        if "delete" in tool_name and today_deletions >= self.policies["max_daily_deletions"]:
            return False, "Daily deletion limit reached"
        
        return True, "Policies passed"
    
    def approval_callback(self, tool_name, args, risk_level):
        # Check policies first
        allowed, reason = self.check_policies(tool_name, args)
        if not allowed:
            logging.warning(f"Policy rejection: {tool_name} - {reason}")
            return {"approved": False, "reason": reason}
        
        # Log the request
        approval_request = {
            "timestamp": datetime.datetime.now().isoformat(),
            "tool": tool_name,
            "args": args,
            "risk_level": risk_level,
            "date": str(datetime.date.today())
        }
        
        # Get approval based on risk level
        if risk_level == "critical":
            print(f"\nüö® CRITICAL OPERATION REQUESTED üö®")
            print(f"Tool: {tool_name}")
            print(f"Arguments: {json.dumps(args, indent=2)}")
            print(f"Policies: ‚úì Passed")
            
            # Could integrate with external approval system here
            # For demo, we'll use console input
            response = input("Enter approval code (or 'deny'): ")
            
            if response == "deny":
                approval_request["approved"] = False
                approval_request["approver"] = "manual"
            else:
                # Verify approval code (simplified)
                approval_request["approved"] = response == "12345"
                approval_request["approver"] = "manual"
                approval_request["approval_code"] = response
        else:
            # Auto-approve lower risk with logging
            approval_request["approved"] = True
            approval_request["approver"] = "automatic"
        
        # Log the decision
        self.approval_history.append(approval_request)
        logging.info(json.dumps(approval_request))
        
        return {
            "approved": approval_request["approved"],
            "reason": reason if not approval_request["approved"] else "Approved"
        }

# Use the approval system
approval_system = ApprovalSystem()

@tool
@require_approval(risk_level="critical")
def delete_all_records(table_name: str) -> str:
    """Delete all records from a table"""
    return f"All records deleted from {table_name}"

agent = Agent(
    name="Secure Agent",
    instructions="You help with data management following security policies",
    tools=[delete_all_records],
    approval_callback=approval_system.approval_callback
)
```

### 2. Human-to-Human Handoff Pattern

```python
from praisonaiagents import Agent, tool

class CustomerServiceSystem:
    def __init__(self):
        self.escalation_queue = []
        self.specialists = {
            "billing": "billing@company.com",
            "technical": "tech@company.com",
            "management": "manager@company.com"
        }
    
    @tool
    def escalate_to_human(self, issue_type: str, customer_id: str, context: str) -> str:
        """Escalate issue to human specialist"""
        specialist = self.specialists.get(issue_type, "support@company.com")
        
        escalation = {
            "customer_id": customer_id,
            "issue_type": issue_type,
            "context": context,
            "specialist": specialist,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        self.escalation_queue.append(escalation)
        
        # In production, this would notify the specialist
        return f"Issue escalated to {specialist}. Ticket #ESC{len(self.escalation_queue):04d}"

# Create customer service agent with escalation
cs_system = CustomerServiceSystem()

support_agent = Agent(
    name="Support Agent",
    instructions="""You are a customer support agent. 
    Handle routine inquiries but escalate complex issues:
    - Billing disputes over $500 ‚Üí billing specialist
    - Technical issues you can't resolve ‚Üí technical specialist  
    - Angry customers demanding managers ‚Üí management
    """,
    tools=[cs_system.escalate_to_human]
)

# Example conversation
response = support_agent.start("""
Customer says: "I've been charged $1,200 incorrectly and I'm very upset! 
I want to speak to a manager right now!"
""")
# Agent will recognize this needs escalation to management
```

### 3. Approval with Context and Modification

```python
from praisonaiagents import Agent, tool, require_approval
import json

class SmartApprovalSystem:
    def __init__(self):
        self.context_memory = {}
    
    def approval_callback(self, tool_name, args, risk_level, context=None):
        print(f"\n{'='*50}")
        print(f"üîç Approval Request: {tool_name}")
        print(f"Risk Level: {risk_level}")
        print(f"Arguments: {json.dumps(args, indent=2)}")
        
        if context:
            print(f"Context: {context}")
        
        # Show similar past operations
        if tool_name in self.context_memory:
            print(f"\nüìä Previous operations:")
            for past_op in self.context_memory[tool_name][-3:]:
                print(f"  - {past_op['timestamp']}: {past_op['args']} ‚Üí {past_op['result']}")
        
        print(f"\nOptions:")
        print("1. Approve as-is")
        print("2. Modify arguments")
        print("3. Deny")
        print("4. Approve with conditions")
        
        choice = input("Choice (1-4): ")
        
        if choice == "1":
            self._record_operation(tool_name, args, "approved")
            return {"approved": True}
        
        elif choice == "2":
            print("\nCurrent arguments:")
            for key, value in args.items():
                new_value = input(f"{key} [{value}]: ") or value
                args[key] = new_value
            
            print(f"\nModified arguments: {json.dumps(args, indent=2)}")
            confirm = input("Confirm modifications? (y/n): ")
            
            if confirm.lower() == 'y':
                self._record_operation(tool_name, args, "modified")
                return {"approved": True, "modified_args": args}
            else:
                return {"approved": False, "reason": "Modification cancelled"}
        
        elif choice == "3":
            reason = input("Denial reason: ")
            self._record_operation(tool_name, args, "denied", reason)
            return {"approved": False, "reason": reason}
        
        elif choice == "4":
            conditions = input("Enter conditions: ")
            self._record_operation(tool_name, args, "conditional", conditions)
            return {
                "approved": True,
                "conditions": conditions,
                "callback_after": True  # Request callback after execution
            }
    
    def _record_operation(self, tool_name, args, result, extra=None):
        if tool_name not in self.context_memory:
            self.context_memory[tool_name] = []
        
        record = {
            "timestamp": datetime.datetime.now().isoformat(),
            "args": args,
            "result": result
        }
        if extra:
            record["extra"] = extra
        
        self.context_memory[tool_name].append(record)

# Example with smart approval
smart_approval = SmartApprovalSystem()

@tool
@require_approval(risk_level="high")
def modify_pricing(product_id: str, new_price: float, effective_date: str) -> str:
    """Modify product pricing"""
    return f"Price for {product_id} updated to ${new_price} effective {effective_date}"

pricing_agent = Agent(
    name="Pricing Manager",
    instructions="You help manage product pricing with oversight",
    tools=[modify_pricing],
    approval_callback=smart_approval.approval_callback
)

# The approval system will show context and allow modifications
response = pricing_agent.start("Update product ABC123 price to $99.99 starting tomorrow")
```

## Integration with External Systems

### 1. Slack Integration for Approvals

```python
from praisonaiagents import Agent, tool, require_approval
import asyncio
from slack_sdk.web.async_client import AsyncWebClient
import uuid

class SlackApprovalSystem:
    def __init__(self, slack_token, approval_channel):
        self.slack = AsyncWebClient(token=slack_token)
        self.channel = approval_channel
        self.pending_approvals = {}
    
    async def request_approval_via_slack(self, tool_name, args, risk_level):
        approval_id = str(uuid.uuid4())
        
        # Create approval message
        blocks = [
            {
                "type": "header",
                "text": {"type": "plain_text", "text": f"üîê Approval Request: {tool_name}"}
            },
            {
                "type": "section",
                "fields": [
                    {"type": "mrkdwn", "text": f"*Risk Level:* {risk_level}"},
                    {"type": "mrkdwn", "text": f"*Request ID:* {approval_id}"}
                ]
            },
            {
                "type": "section",
                "text": {"type": "mrkdwn", "text": f"*Arguments:*\n```{json.dumps(args, indent=2)}```"}
            },
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {"type": "plain_text", "text": "‚úÖ Approve"},
                        "style": "primary",
                        "action_id": f"approve_{approval_id}"
                    },
                    {
                        "type": "button",
                        "text": {"type": "plain_text", "text": "‚ùå Deny"},
                        "style": "danger",
                        "action_id": f"deny_{approval_id}"
                    }
                ]
            }
        ]
        
        # Send to Slack
        await self.slack.chat_postMessage(
            channel=self.channel,
            blocks=blocks
        )
        
        # Wait for response (with timeout)
        self.pending_approvals[approval_id] = None
        
        for _ in range(300):  # 5 minute timeout
            await asyncio.sleep(1)
            if self.pending_approvals[approval_id] is not None:
                return self.pending_approvals[approval_id]
        
        return {"approved": False, "reason": "Timeout"}
    
    def approval_callback(self, tool_name, args, risk_level):
        # Run async function in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(
            self.request_approval_via_slack(tool_name, args, risk_level)
        )
        loop.close()
        return result

# Usage
slack_approval = SlackApprovalSystem(
    slack_token="xoxb-your-token",
    approval_channel="#approvals"
)

@tool
@require_approval(risk_level="high")
def production_deployment(service: str, version: str) -> str:
    """Deploy service to production"""
    return f"Deployed {service} version {version} to production"

deployment_agent = Agent(
    name="Deployment Bot",
    instructions="You help with production deployments",
    tools=[production_deployment],
    approval_callback=slack_approval.approval_callback
)
```

### 2. Email-Based Approval Workflow

```python
from praisonaiagents import Agent, tool, require_approval
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import hashlib
import time

class EmailApprovalSystem:
    def __init__(self, smtp_config, approvers):
        self.smtp_config = smtp_config
        self.approvers = approvers  # List of approver emails
        self.approval_tokens = {}
    
    def generate_approval_link(self, approval_id):
        base_url = "https://approvals.company.com"
        token = hashlib.sha256(f"{approval_id}{time.time()}".encode()).hexdigest()
        self.approval_tokens[token] = approval_id
        return f"{base_url}/approve/{token}", f"{base_url}/deny/{token}"
    
    def send_approval_email(self, tool_name, args, risk_level):
        approval_id = str(uuid.uuid4())
        approve_link, deny_link = self.generate_approval_link(approval_id)
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f"[{risk_level.upper()}] Approval Required: {tool_name}"
        msg['From'] = self.smtp_config['from']
        msg['To'] = ', '.join(self.approvers)
        
        html = f"""
        <html>
        <body>
            <h2>üîê Approval Request</h2>
            <p><strong>Tool:</strong> {tool_name}</p>
            <p><strong>Risk Level:</strong> <span style="color: red">{risk_level}</span></p>
            <p><strong>Arguments:</strong></p>
            <pre>{json.dumps(args, indent=2)}</pre>
            
            <div style="margin-top: 20px">
                <a href="{approve_link}" style="background: green; color: white; padding: 10px 20px; text-decoration: none; margin-right: 10px">
                    ‚úÖ Approve
                </a>
                <a href="{deny_link}" style="background: red; color: white; padding: 10px 20px; text-decoration: none">
                    ‚ùå Deny
                </a>
            </div>
            
            <p style="margin-top: 20px; font-size: 12px; color: gray">
                This approval request will expire in 1 hour.
            </p>
        </body>
        </html>
        """
        
        msg.attach(MIMEText(html, 'html'))
        
        # Send email
        with smtplib.SMTP(self.smtp_config['host'], self.smtp_config['port']) as server:
            server.starttls()
            server.login(self.smtp_config['user'], self.smtp_config['password'])
            server.send_message(msg)
        
        # In production, this would wait for webhook callback
        # For demo, we'll simulate waiting
        print(f"Approval email sent. Waiting for response...")
        # ... webhook handling code ...
        
        return {"approved": True}  # Placeholder

# Usage
email_approval = EmailApprovalSystem(
    smtp_config={
        'host': 'smtp.gmail.com',
        'port': 587,
        'user': 'approvals@company.com',
        'password': 'app-password',
        'from': 'AI System <approvals@company.com>'
    },
    approvers=['manager@company.com', 'security@company.com']
)
```

## Approval Patterns for Specific Use Cases

### 1. Financial Transaction Approvals

```python
from praisonaiagents import Agent, tool, require_approval
from decimal import Decimal

class FinancialApprovalSystem:
    def __init__(self):
        self.limits = {
            "junior": Decimal("1000"),
            "senior": Decimal("10000"),
            "executive": Decimal("100000")
        }
        self.daily_totals = {}
    
    def approval_callback(self, tool_name, args, risk_level):
        amount = Decimal(str(args.get('amount', 0)))
        today = datetime.date.today()
        
        # Track daily totals
        if today not in self.daily_totals:
            self.daily_totals[today] = Decimal("0")
        
        # Check limits based on amount
        if amount <= self.limits["junior"]:
            print(f"Auto-approved: ${amount} within junior limit")
            self.daily_totals[today] += amount
            return {"approved": True, "approver": "automatic"}
        
        elif amount <= self.limits["senior"]:
            print(f"Senior approval required for ${amount}")
            # In production, route to senior approver
            code = input("Enter senior approval code: ")
            if code == "senior123":
                self.daily_totals[today] += amount
                return {"approved": True, "approver": "senior"}
        
        else:
            print(f"Executive approval required for ${amount}")
            # In production, route to executive
            code = input("Enter executive approval code: ")
            if code == "exec123":
                self.daily_totals[today] += amount
                return {"approved": True, "approver": "executive"}
        
        return {"approved": False, "reason": "Invalid approval code"}

@tool
@require_approval(risk_level="high")
def process_payment(recipient: str, amount: float, currency: str = "USD") -> str:
    """Process financial payment"""
    return f"Payment of {amount} {currency} sent to {recipient}"

@tool
@require_approval(risk_level="medium")
def issue_refund(order_id: str, amount: float, reason: str) -> str:
    """Issue customer refund"""
    return f"Refund of ${amount} issued for order {order_id}"

financial_approval = FinancialApprovalSystem()

finance_agent = Agent(
    name="Finance Assistant",
    instructions="You help process financial transactions with appropriate approvals",
    tools=[process_payment, issue_refund],
    approval_callback=financial_approval.approval_callback
)
```

### 2. Data Access Approvals with Audit Trail

```python
from praisonaiagents import Agent, tool, require_approval
import sqlite3
from datetime import datetime

class DataAccessApprovalSystem:
    def __init__(self, db_path="approvals.db"):
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS access_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                user_id TEXT,
                tool_name TEXT,
                data_requested TEXT,
                purpose TEXT,
                approved BOOLEAN,
                approver TEXT,
                justification TEXT
            )
        """)
        conn.commit()
        conn.close()
    
    def approval_callback(self, tool_name, args, risk_level):
        # Extract relevant information
        data_requested = args.get('query', args.get('dataset', 'unknown'))
        purpose = args.get('purpose', 'not specified')
        
        print(f"\nüìä Data Access Request")
        print(f"Data: {data_requested}")
        print(f"Purpose: {purpose}")
        print(f"Risk Level: {risk_level}")
        
        # Check if this is sensitive data
        sensitive_keywords = ['personal', 'financial', 'medical', 'confidential']
        is_sensitive = any(keyword in str(data_requested).lower() 
                         for keyword in sensitive_keywords)
        
        if is_sensitive:
            print("‚ö†Ô∏è  This request involves sensitive data!")
            justification = input("Please provide justification: ")
            approver = input("Approver name: ")
            approved = input("Approve? (y/n): ").lower() == 'y'
        else:
            justification = "Auto-approved: non-sensitive data"
            approver = "system"
            approved = True
        
        # Log to database
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO access_log 
            (timestamp, user_id, tool_name, data_requested, purpose, approved, approver, justification)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            datetime.now().isoformat(),
            "current_user",  # Would be actual user in production
            tool_name,
            data_requested,
            purpose,
            approved,
            approver,
            justification
        ))
        conn.commit()
        conn.close()
        
        return {
            "approved": approved,
            "reason": justification if not approved else None
        }

@tool
@require_approval(risk_level="high")
def query_customer_data(query: str, purpose: str) -> str:
    """Query customer database"""
    # Actual query execution
    return "Query results..."

@tool  
@require_approval(risk_level="medium")
def export_dataset(dataset: str, format: str, purpose: str) -> str:
    """Export dataset"""
    return f"Dataset {dataset} exported to {format}"

data_approval = DataAccessApprovalSystem()

data_agent = Agent(
    name="Data Access Agent",
    instructions="You help users access data with proper authorization",
    tools=[query_customer_data, export_dataset],
    approval_callback=data_approval.approval_callback
)

# Generate audit report
def generate_audit_report(db_path="approvals.db"):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT timestamp, user_id, data_requested, approved, approver
        FROM access_log
        WHERE timestamp > datetime('now', '-7 days')
        ORDER BY timestamp DESC
    """)
    
    print("\nüìã Weekly Data Access Audit Report")
    print("="*60)
    for row in cursor.fetchall():
        print(f"{row[0]} | {row[1]} | {row[2]} | {'‚úÖ' if row[3] else '‚ùå'} | {row[4]}")
    
    conn.close()
```

## Best Practices

### 1. Design Clear Risk Levels

```python
# Define clear risk categories
RISK_LEVELS = {
    "critical": [
        "delete_all", "drop_table", "execute_raw_sql", 
        "modify_security_settings", "access_encryption_keys"
    ],
    "high": [
        "delete_user", "modify_permissions", "export_sensitive_data",
        "process_payment", "send_bulk_emails"
    ],
    "medium": [
        "update_record", "send_notification", "generate_report",
        "modify_settings", "access_logs"
    ],
    "low": [
        "read_data", "list_items", "get_status",
        "view_dashboard", "search_public_data"
    ]
}
```

### 2. Implement Approval Bypass for Emergencies

```python
class EmergencyOverrideSystem:
    def __init__(self):
        self.emergency_codes = {}
        self.override_log = []
    
    def generate_emergency_code(self, reason, valid_for_minutes=30):
        code = str(uuid.uuid4())[:8]
        self.emergency_codes[code] = {
            "reason": reason,
            "created": datetime.now(),
            "expires": datetime.now() + timedelta(minutes=valid_for_minutes)
        }
        return code
    
    def approval_callback(self, tool_name, args, risk_level):
        # Check for emergency override
        override_code = args.get('_emergency_override')
        if override_code and override_code in self.emergency_codes:
            code_info = self.emergency_codes[override_code]
            if datetime.now() < code_info["expires"]:
                self.override_log.append({
                    "tool": tool_name,
                    "timestamp": datetime.now(),
                    "reason": code_info["reason"],
                    "code": override_code
                })
                return {"approved": True, "reason": f"Emergency override: {code_info['reason']}"}
        
        # Normal approval flow
        return standard_approval(tool_name, args, risk_level)
```

### 3. Context-Aware Approvals

```python
def context_aware_approval(tool_name, args, risk_level, context):
    """Approval that considers context"""
    
    # Check time-based context
    current_hour = datetime.now().hour
    is_business_hours = 9 <= current_hour <= 17
    
    # Check user context
    user_role = context.get("user_role", "standard")
    user_history = context.get("approval_history", [])
    
    # Check environment context
    environment = context.get("environment", "production")
    
    # Apply different rules based on context
    if environment == "development":
        # More lenient in dev
        return {"approved": True, "reason": "Auto-approved in development"}
    
    if not is_business_hours and risk_level in ["high", "critical"]:
        # Stricter outside business hours
        return {
            "approved": False, 
            "reason": "High-risk operations not allowed outside business hours"
        }
    
    if user_role == "admin" and len(user_history) > 10:
        # Trust established admins more
        if risk_level != "critical":
            return {"approved": True, "reason": "Trusted admin auto-approval"}
    
    # Default to standard approval
    return standard_approval(tool_name, args, risk_level)
```

## Conclusion

The approval system in PraisonAI provides flexible and powerful mechanisms for implementing human oversight in AI systems. From simple approval prompts to sophisticated multi-level workflows integrated with external systems, these patterns enable you to build AI applications that maintain human control while leveraging automation benefits.

## Next Steps

- Explore [MCP SSE Examples](./mcp-sse-streaming.mdx) for real-time approval notifications
- Learn about [Session Persistence](./session-persistence.mdx) for approval history tracking
- Check out [Multi-Provider Examples](./multi-provider-switching.mdx) for approval across different AI providers