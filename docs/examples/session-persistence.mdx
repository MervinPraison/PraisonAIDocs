---
title: Session Persistence for Stateful Applications
description: Learn how to build stateful AI applications with persistent sessions and state management
---

# Session Persistence for Stateful Applications

Session persistence in PraisonAI enables building stateful applications that maintain context across interactions, supporting complex workflows, multi-turn conversations, and personalized experiences.

## Overview

Session persistence provides:
- Conversation continuity across multiple interactions
- State management for complex workflows
- User-specific memory and preferences
- Checkpoint and recovery capabilities
- Distributed state synchronization
- Transaction-like state operations

## Basic Session Management

### Simple Session Creation

```python
from praisonaiagents import Agent, Session

# Create a new session
session = Session(
    session_id="user-123-session",
    user_id="user-123"
)

# Create agent with session
agent = Agent(
    name="Stateful Assistant",
    instructions="You maintain context across conversations",
    session=session
)

# First interaction
response1 = agent.start("My name is Alice and I work at TechCorp")
print(response1)  # "Nice to meet you, Alice! How can I help you at TechCorp?"

# Second interaction (remembers context)
response2 = agent.start("What's my name?")
print(response2)  # "Your name is Alice."

# Third interaction
response3 = agent.start("Where do I work?")
print(response3)  # "You work at TechCorp."
```

### Session Save and Restore

```python
from praisonaiagents import Agent, Session
import json

# Create and use a session
session = Session(session_id="project-alpha")
agent = Agent(
    name="Project Manager",
    instructions="You help manage projects",
    session=session
)

# Work with the session
agent.start("Project Alpha is a web application for customer management")
agent.start("The deadline is March 15, 2024")
agent.start("Team members: John (frontend), Sarah (backend), Mike (design)")

# Save session state
session_data = session.save()
with open("project-alpha-session.json", "w") as f:
    json.dump(session_data, f)

# Later, restore the session
with open("project-alpha-session.json", "r") as f:
    session_data = json.load(f)

restored_session = Session.load(session_data)
restored_agent = Agent(
    name="Project Manager",
    instructions="You help manage projects",
    session=restored_session
)

# Context is preserved
response = restored_agent.start("What's the project deadline?")
print(response)  # "The deadline for Project Alpha is March 15, 2024."
```

## Advanced State Management

### 1. Structured State Storage

```python
from praisonaiagents import Agent, Session
from typing import Dict, Any
import datetime

class StatefulWorkflowSession(Session):
    def __init__(self, session_id: str, **kwargs):
        super().__init__(session_id, **kwargs)
        self.workflow_state = {
            "current_step": "initialization",
            "completed_steps": [],
            "pending_tasks": [],
            "data": {},
            "checkpoints": []
        }
    
    def update_step(self, step_name: str):
        """Update current workflow step"""
        self.workflow_state["completed_steps"].append(self.workflow_state["current_step"])
        self.workflow_state["current_step"] = step_name
        self.add_checkpoint()
    
    def add_task(self, task: Dict[str, Any]):
        """Add a pending task"""
        task["created_at"] = datetime.datetime.now().isoformat()
        self.workflow_state["pending_tasks"].append(task)
    
    def complete_task(self, task_id: str):
        """Mark task as completed"""
        self.workflow_state["pending_tasks"] = [
            t for t in self.workflow_state["pending_tasks"] 
            if t.get("id") != task_id
        ]
    
    def set_data(self, key: str, value: Any):
        """Store workflow data"""
        self.workflow_state["data"][key] = value
    
    def get_data(self, key: str, default=None):
        """Retrieve workflow data"""
        return self.workflow_state["data"].get(key, default)
    
    def add_checkpoint(self):
        """Create a checkpoint of current state"""
        checkpoint = {
            "timestamp": datetime.datetime.now().isoformat(),
            "state": self.workflow_state.copy(),
            "memory_snapshot": self.memory.get_all() if hasattr(self, 'memory') else None
        }
        self.workflow_state["checkpoints"].append(checkpoint)
        
        # Keep only last 10 checkpoints
        if len(self.workflow_state["checkpoints"]) > 10:
            self.workflow_state["checkpoints"].pop(0)
    
    def restore_checkpoint(self, checkpoint_index: int = -1):
        """Restore from checkpoint"""
        if self.workflow_state["checkpoints"]:
            checkpoint = self.workflow_state["checkpoints"][checkpoint_index]
            self.workflow_state = checkpoint["state"].copy()
            # Restore memory if available
            if checkpoint["memory_snapshot"] and hasattr(self, 'memory'):
                self.memory.restore(checkpoint["memory_snapshot"])

# Use structured session
workflow_session = StatefulWorkflowSession("order-processing")

agent = Agent(
    name="Order Processor",
    instructions="You help process customer orders through various stages",
    session=workflow_session
)

# Process order workflow
agent.start("New order received: #12345 for customer John Doe")
workflow_session.set_data("order_id", "12345")
workflow_session.set_data("customer", "John Doe")

workflow_session.update_step("validation")
agent.start("Validate customer credit and inventory")

workflow_session.update_step("payment")
agent.start("Process payment of $150")
workflow_session.set_data("payment_status", "completed")

# Check current state
print(f"Current step: {workflow_session.workflow_state['current_step']}")
print(f"Completed steps: {workflow_session.workflow_state['completed_steps']}")
print(f"Order data: {workflow_session.workflow_state['data']}")
```

### 2. Multi-Agent Shared Sessions

```python
from praisonaiagents import Agent, Session
import threading
import time

class SharedSession(Session):
    def __init__(self, session_id: str, **kwargs):
        super().__init__(session_id, **kwargs)
        self._lock = threading.Lock()
        self.agent_states = {}
        self.shared_memory = {}
    
    def register_agent(self, agent_id: str):
        """Register an agent with the session"""
        with self._lock:
            self.agent_states[agent_id] = {
                "status": "active",
                "last_activity": time.time(),
                "private_state": {}
            }
    
    def update_agent_state(self, agent_id: str, key: str, value: Any):
        """Update agent-specific state"""
        with self._lock:
            if agent_id in self.agent_states:
                self.agent_states[agent_id]["private_state"][key] = value
                self.agent_states[agent_id]["last_activity"] = time.time()
    
    def get_agent_state(self, agent_id: str, key: str, default=None):
        """Get agent-specific state"""
        with self._lock:
            if agent_id in self.agent_states:
                return self.agent_states[agent_id]["private_state"].get(key, default)
            return default
    
    def update_shared_memory(self, key: str, value: Any, agent_id: str = None):
        """Update shared memory with optional locking"""
        with self._lock:
            self.shared_memory[key] = {
                "value": value,
                "updated_by": agent_id,
                "timestamp": time.time()
            }
    
    def get_shared_memory(self, key: str, default=None):
        """Get from shared memory"""
        with self._lock:
            if key in self.shared_memory:
                return self.shared_memory[key]["value"]
            return default

# Create shared session for multi-agent system
shared_session = SharedSession("research-project")

# Create multiple agents sharing the session
researcher = Agent(
    name="Researcher",
    instructions="You research topics and gather information",
    session=shared_session
)
shared_session.register_agent("researcher")

analyst = Agent(
    name="Analyst",
    instructions="You analyze data and identify patterns",
    session=shared_session
)
shared_session.register_agent("analyst")

writer = Agent(
    name="Writer",
    instructions="You create reports based on research and analysis",
    session=shared_session
)
shared_session.register_agent("writer")

# Agents work together with shared state
researcher.start("Research climate change impacts on agriculture")
shared_session.update_shared_memory(
    "research_findings", 
    ["Drought increases", "Crop yield changes", "Temperature shifts"],
    "researcher"
)

# Analyst accesses shared research
findings = shared_session.get_shared_memory("research_findings")
analyst.start(f"Analyze these findings: {findings}")
shared_session.update_shared_memory(
    "analysis_results",
    {"risk_level": "high", "affected_regions": ["Midwest", "California"]},
    "analyst"
)

# Writer uses both research and analysis
writer.start("Write executive summary based on research and analysis")
```

### 3. Persistent Storage Backends

```python
from praisonaiagents import Session
import sqlite3
import redis
import json
from abc import ABC, abstractmethod

class PersistenceBackend(ABC):
    @abstractmethod
    def save(self, session_id: str, data: dict):
        pass
    
    @abstractmethod
    def load(self, session_id: str) -> dict:
        pass
    
    @abstractmethod
    def delete(self, session_id: str):
        pass

class SQLitePersistence(PersistenceBackend):
    def __init__(self, db_path: str = "sessions.db"):
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS sessions (
                session_id TEXT PRIMARY KEY,
                data TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        conn.close()
    
    def save(self, session_id: str, data: dict):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT OR REPLACE INTO sessions (session_id, data, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
        """, (session_id, json.dumps(data)))
        conn.commit()
        conn.close()
    
    def load(self, session_id: str) -> dict:
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT data FROM sessions WHERE session_id = ?", (session_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return json.loads(row[0])
        return None

class RedisPersistence(PersistenceBackend):
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis_client = redis.from_url(redis_url)
    
    def save(self, session_id: str, data: dict):
        # Set with 24 hour expiration
        self.redis_client.setex(
            f"session:{session_id}",
            86400,  # 24 hours
            json.dumps(data)
        )
    
    def load(self, session_id: str) -> dict:
        data = self.redis_client.get(f"session:{session_id}")
        if data:
            return json.loads(data)
        return None
    
    def delete(self, session_id: str):
        self.redis_client.delete(f"session:{session_id}")

# Custom session with persistence
class PersistentSession(Session):
    def __init__(self, session_id: str, backend: PersistenceBackend, **kwargs):
        super().__init__(session_id, **kwargs)
        self.backend = backend
        
        # Try to load existing session
        existing_data = self.backend.load(session_id)
        if existing_data:
            self.restore(existing_data)
    
    def save(self):
        """Save session to backend"""
        data = super().save()
        self.backend.save(self.session_id, data)
        return data
    
    def auto_save(self):
        """Enable auto-save after each interaction"""
        original_add_message = self.add_message
        
        def wrapped_add_message(*args, **kwargs):
            result = original_add_message(*args, **kwargs)
            self.save()  # Auto-save after adding message
            return result
        
        self.add_message = wrapped_add_message

# Use with different backends
# SQLite for local persistence
sqlite_session = PersistentSession(
    "user-123",
    SQLitePersistence("./data/sessions.db")
)

# Redis for distributed persistence
redis_session = PersistentSession(
    "user-456",
    RedisPersistence("redis://localhost:6379")
)

# Enable auto-save
sqlite_session.auto_save()

agent = Agent(
    name="Persistent Assistant",
    session=sqlite_session
)

# All interactions are automatically persisted
agent.start("Remember that my favorite color is blue")
```

## Stateful Application Patterns

### 1. Conversational Commerce Bot

```python
from praisonaiagents import Agent, Session
from enum import Enum
from typing import List, Dict

class OrderState(Enum):
    BROWSING = "browsing"
    CART = "cart"
    CHECKOUT = "checkout"
    PAYMENT = "payment"
    CONFIRMED = "confirmed"

class CommerceSession(Session):
    def __init__(self, session_id: str, user_id: str):
        super().__init__(session_id, user_id=user_id)
        self.cart: List[Dict] = []
        self.order_state = OrderState.BROWSING
        self.user_preferences = {}
        self.order_history = []
    
    def add_to_cart(self, item: Dict):
        """Add item to cart"""
        self.cart.append({
            **item,
            "added_at": datetime.datetime.now().isoformat()
        })
        self.order_state = OrderState.CART
    
    def remove_from_cart(self, item_id: str):
        """Remove item from cart"""
        self.cart = [item for item in self.cart if item.get("id") != item_id]
    
    def get_cart_total(self) -> float:
        """Calculate cart total"""
        return sum(item.get("price", 0) * item.get("quantity", 1) for item in self.cart)
    
    def checkout(self) -> Dict:
        """Move to checkout"""
        if not self.cart:
            return {"error": "Cart is empty"}
        
        self.order_state = OrderState.CHECKOUT
        return {
            "items": self.cart,
            "total": self.get_cart_total(),
            "state": self.order_state.value
        }
    
    def complete_order(self, payment_info: Dict) -> Dict:
        """Complete the order"""
        order = {
            "order_id": f"ORD-{int(time.time())}",
            "items": self.cart.copy(),
            "total": self.get_cart_total(),
            "payment": payment_info,
            "timestamp": datetime.datetime.now().isoformat(),
            "user_id": self.user_id
        }
        
        self.order_history.append(order)
        self.cart = []
        self.order_state = OrderState.CONFIRMED
        
        return order

# Commerce bot implementation
def create_commerce_bot(session: CommerceSession):
    agent = Agent(
        name="Shopping Assistant",
        instructions="""You are a helpful shopping assistant. You can:
        - Show products and recommendations
        - Add/remove items from cart
        - Process checkout and payments
        - Remember user preferences and order history
        """,
        session=session
    )
    
    @agent.tool
    def view_cart() -> str:
        """View current cart contents"""
        if not session.cart:
            return "Your cart is empty"
        
        cart_text = "Your cart:\n"
        for item in session.cart:
            cart_text += f"- {item['name']} (${item['price']}) x{item.get('quantity', 1)}\n"
        cart_text += f"\nTotal: ${session.get_cart_total():.2f}"
        return cart_text
    
    @agent.tool
    def add_product(product_name: str, price: float, quantity: int = 1) -> str:
        """Add product to cart"""
        item = {
            "id": f"prod-{len(session.cart) + 1}",
            "name": product_name,
            "price": price,
            "quantity": quantity
        }
        session.add_to_cart(item)
        return f"Added {product_name} to cart. Total: ${session.get_cart_total():.2f}"
    
    @agent.tool
    def proceed_to_checkout() -> str:
        """Proceed to checkout"""
        result = session.checkout()
        if "error" in result:
            return result["error"]
        
        return f"Proceeding to checkout. Total: ${result['total']:.2f}. Please provide payment details."
    
    return agent

# Use the commerce bot
commerce_session = CommerceSession("session-789", "user-789")
bot = create_commerce_bot(commerce_session)

# Shopping conversation
bot.start("I'm looking for a new laptop")
bot.start("Add a MacBook Pro for $1999 to my cart")
bot.start("Also add a laptop case for $49")
bot.start("Show me my cart")
bot.start("Proceed to checkout")

# Session persists cart state across interactions
print(f"Cart items: {len(commerce_session.cart)}")
print(f"Order state: {commerce_session.order_state.value}")
```

### 2. Project Management Assistant

```python
from praisonaiagents import Agent, Session
from dataclasses import dataclass
from typing import List, Optional
import uuid

@dataclass
class Task:
    id: str
    title: str
    description: str
    assignee: Optional[str]
    status: str  # todo, in_progress, done
    created_at: str
    due_date: Optional[str]
    dependencies: List[str]

class ProjectSession(Session):
    def __init__(self, session_id: str, project_name: str):
        super().__init__(session_id)
        self.project_name = project_name
        self.tasks: Dict[str, Task] = {}
        self.team_members: List[str] = []
        self.milestones: List[Dict] = []
        self.activity_log: List[Dict] = []
    
    def create_task(self, title: str, description: str, **kwargs) -> Task:
        """Create a new task"""
        task = Task(
            id=str(uuid.uuid4())[:8],
            title=title,
            description=description,
            assignee=kwargs.get("assignee"),
            status="todo",
            created_at=datetime.datetime.now().isoformat(),
            due_date=kwargs.get("due_date"),
            dependencies=kwargs.get("dependencies", [])
        )
        
        self.tasks[task.id] = task
        self.log_activity("task_created", {"task_id": task.id, "title": title})
        return task
    
    def update_task_status(self, task_id: str, new_status: str):
        """Update task status"""
        if task_id in self.tasks:
            old_status = self.tasks[task_id].status
            self.tasks[task_id].status = new_status
            self.log_activity("task_updated", {
                "task_id": task_id,
                "old_status": old_status,
                "new_status": new_status
            })
    
    def assign_task(self, task_id: str, assignee: str):
        """Assign task to team member"""
        if task_id in self.tasks:
            self.tasks[task_id].assignee = assignee
            if assignee not in self.team_members:
                self.team_members.append(assignee)
            self.log_activity("task_assigned", {
                "task_id": task_id,
                "assignee": assignee
            })
    
    def get_tasks_by_status(self, status: str) -> List[Task]:
        """Get tasks by status"""
        return [task for task in self.tasks.values() if task.status == status]
    
    def get_tasks_by_assignee(self, assignee: str) -> List[Task]:
        """Get tasks by assignee"""
        return [task for task in self.tasks.values() if task.assignee == assignee]
    
    def add_milestone(self, name: str, date: str, description: str):
        """Add project milestone"""
        milestone = {
            "id": str(uuid.uuid4())[:8],
            "name": name,
            "date": date,
            "description": description,
            "created_at": datetime.datetime.now().isoformat()
        }
        self.milestones.append(milestone)
        self.log_activity("milestone_added", {"milestone": name})
    
    def log_activity(self, activity_type: str, details: Dict):
        """Log project activity"""
        self.activity_log.append({
            "timestamp": datetime.datetime.now().isoformat(),
            "type": activity_type,
            "details": details
        })
    
    def get_project_summary(self) -> Dict:
        """Get project summary"""
        total_tasks = len(self.tasks)
        completed_tasks = len(self.get_tasks_by_status("done"))
        
        return {
            "project_name": self.project_name,
            "total_tasks": total_tasks,
            "completed_tasks": completed_tasks,
            "completion_percentage": (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0,
            "team_size": len(self.team_members),
            "upcoming_milestones": [m for m in self.milestones if m["date"] > datetime.datetime.now().isoformat()],
            "recent_activity": self.activity_log[-5:]
        }

# Create project management bot
project_session = ProjectSession("proj-001", "Website Redesign")

project_agent = Agent(
    name="Project Manager",
    instructions="""You are a project management assistant. You help:
    - Create and track tasks
    - Assign work to team members
    - Monitor project progress
    - Set milestones and deadlines
    """,
    session=project_session
)

# Add tools for project management
@project_agent.tool
def create_task(title: str, description: str, assignee: str = None, due_date: str = None) -> str:
    """Create a new project task"""
    task = project_session.create_task(
        title=title,
        description=description,
        assignee=assignee,
        due_date=due_date
    )
    return f"Created task {task.id}: {title}"

@project_agent.tool
def list_tasks(status: str = None, assignee: str = None) -> str:
    """List project tasks"""
    if status:
        tasks = project_session.get_tasks_by_status(status)
        filter_desc = f"with status '{status}'"
    elif assignee:
        tasks = project_session.get_tasks_by_assignee(assignee)
        filter_desc = f"assigned to {assignee}"
    else:
        tasks = list(project_session.tasks.values())
        filter_desc = ""
    
    if not tasks:
        return f"No tasks found {filter_desc}"
    
    result = f"Tasks {filter_desc}:\n"
    for task in tasks:
        result += f"- [{task.id}] {task.title} ({task.status})"
        if task.assignee:
            result += f" - assigned to {task.assignee}"
        result += "\n"
    
    return result

@project_agent.tool
def update_task(task_id: str, status: str) -> str:
    """Update task status"""
    if task_id not in project_session.tasks:
        return f"Task {task_id} not found"
    
    project_session.update_task_status(task_id, status)
    return f"Updated task {task_id} status to {status}"

@project_agent.tool
def project_summary() -> str:
    """Get project summary"""
    summary = project_session.get_project_summary()
    return f"""
Project: {summary['project_name']}
Progress: {summary['completed_tasks']}/{summary['total_tasks']} tasks ({summary['completion_percentage']:.1f}% complete)
Team: {summary['team_size']} members
Upcoming milestones: {len(summary['upcoming_milestones'])}
"""

# Use the project bot
project_agent.start("Create a task for homepage design")
project_agent.start("Assign it to Sarah")
project_agent.start("Create another task for backend API development and assign to John")
project_agent.start("Show me all tasks")
project_agent.start("Update the first task status to in_progress")
project_agent.start("Show project summary")
```

### 3. Learning Assistant with Progress Tracking

```python
from praisonaiagents import Agent, Session
from typing import Dict, List
import random

class LearningSession(Session):
    def __init__(self, session_id: str, user_id: str, subject: str):
        super().__init__(session_id, user_id=user_id)
        self.subject = subject
        self.knowledge_state = {
            "concepts_learned": [],
            "concepts_in_progress": [],
            "quiz_scores": [],
            "total_study_time": 0,
            "last_study_date": None,
            "mastery_level": 0
        }
        self.learning_path = []
        self.personalization = {
            "learning_style": None,  # visual, auditory, kinesthetic
            "pace": "medium",  # slow, medium, fast
            "difficulty_preference": "adaptive"
        }
    
    def update_concept_status(self, concept: str, status: str):
        """Update learning status for a concept"""
        if status == "learned":
            if concept in self.knowledge_state["concepts_in_progress"]:
                self.knowledge_state["concepts_in_progress"].remove(concept)
            if concept not in self.knowledge_state["concepts_learned"]:
                self.knowledge_state["concepts_learned"].append(concept)
        elif status == "in_progress":
            if concept not in self.knowledge_state["concepts_in_progress"]:
                self.knowledge_state["concepts_in_progress"].append(concept)
    
    def record_quiz_score(self, score: float, topic: str):
        """Record quiz performance"""
        self.knowledge_state["quiz_scores"].append({
            "score": score,
            "topic": topic,
            "timestamp": datetime.datetime.now().isoformat()
        })
        
        # Update mastery level
        recent_scores = [q["score"] for q in self.knowledge_state["quiz_scores"][-5:]]
        if recent_scores:
            self.knowledge_state["mastery_level"] = sum(recent_scores) / len(recent_scores)
    
    def get_next_concept(self) -> str:
        """Get next concept to learn based on progress"""
        # Simplified recommendation logic
        if not self.learning_path:
            return "Introduction to " + self.subject
        
        # Find concepts that haven't been learned yet
        remaining = [c for c in self.learning_path 
                    if c not in self.knowledge_state["concepts_learned"]]
        
        if remaining:
            return remaining[0]
        else:
            return "Advanced topics in " + self.subject
    
    def get_progress_report(self) -> Dict:
        """Generate learning progress report"""
        total_concepts = len(self.learning_path) if self.learning_path else 1
        learned_concepts = len(self.knowledge_state["concepts_learned"])
        
        return {
            "subject": self.subject,
            "progress_percentage": (learned_concepts / total_concepts * 100) if total_concepts > 0 else 0,
            "concepts_learned": learned_concepts,
            "concepts_remaining": total_concepts - learned_concepts,
            "average_quiz_score": sum(q["score"] for q in self.knowledge_state["quiz_scores"]) / len(self.knowledge_state["quiz_scores"]) if self.knowledge_state["quiz_scores"] else 0,
            "mastery_level": self.knowledge_state["mastery_level"],
            "study_streak": self._calculate_study_streak()
        }
    
    def _calculate_study_streak(self) -> int:
        """Calculate consecutive days of study"""
        # Simplified - in production would check actual dates
        return len(set(q["timestamp"][:10] for q in self.knowledge_state["quiz_scores"]))

# Create learning assistant
learning_session = LearningSession("learn-001", "student-123", "Python Programming")
learning_session.learning_path = [
    "Variables and Data Types",
    "Control Flow",
    "Functions",
    "Classes and Objects",
    "Modules and Packages",
    "Error Handling",
    "File I/O",
    "Advanced Topics"
]

learning_agent = Agent(
    name="Learning Assistant",
    instructions="""You are a personalized learning assistant. You:
    - Teach concepts adapted to the student's level
    - Track learning progress
    - Provide quizzes and exercises
    - Offer encouragement and feedback
    - Adapt to learning style and pace
    """,
    session=learning_session
)

@learning_agent.tool
def start_lesson(concept: str = None) -> str:
    """Start a new lesson"""
    if not concept:
        concept = learning_session.get_next_concept()
    
    learning_session.update_concept_status(concept, "in_progress")
    learning_session.knowledge_state["last_study_date"] = datetime.datetime.now().isoformat()
    
    return f"Starting lesson on: {concept}\n\nLet's begin with the basics..."

@learning_agent.tool
def complete_lesson(concept: str) -> str:
    """Mark lesson as completed"""
    learning_session.update_concept_status(concept, "learned")
    return f"Great job! You've completed the lesson on {concept}."

@learning_agent.tool
def take_quiz(topic: str, num_questions: int = 5) -> str:
    """Take a quiz on a topic"""
    # Simulate quiz (in production, would have actual questions)
    score = random.uniform(0.6, 1.0)  # Simulate score
    learning_session.record_quiz_score(score, topic)
    
    feedback = "Excellent!" if score > 0.9 else "Good job!" if score > 0.7 else "Keep practicing!"
    return f"Quiz completed! Score: {score*100:.1f}%\n{feedback}"

@learning_agent.tool
def show_progress() -> str:
    """Show learning progress"""
    report = learning_session.get_progress_report()
    return f"""
Learning Progress Report
========================
Subject: {report['subject']}
Progress: {report['progress_percentage']:.1f}% complete
Concepts learned: {report['concepts_learned']}
Concepts remaining: {report['concepts_remaining']}
Average quiz score: {report['average_quiz_score']*100:.1f}%
Mastery level: {report['mastery_level']*100:.1f}%
Study streak: {report['study_streak']} days
"""

# Learning conversation
learning_agent.start("I want to learn Python")
learning_agent.start("Start my first lesson")
learning_agent.start("I think I understand variables now")
learning_agent.start("Complete the current lesson")
learning_agent.start("Can I take a quiz on variables?")
learning_agent.start("Show my progress")
```

## State Synchronization and Transactions

### 1. Transactional State Updates

```python
from praisonaiagents import Session
import copy
from contextlib import contextmanager

class TransactionalSession(Session):
    def __init__(self, session_id: str, **kwargs):
        super().__init__(session_id, **kwargs)
        self._transaction_stack = []
        self._in_transaction = False
    
    @contextmanager
    def transaction(self):
        """Context manager for transactional updates"""
        # Save current state
        self._transaction_stack.append({
            "state": copy.deepcopy(self.__dict__),
            "timestamp": datetime.datetime.now()
        })
        self._in_transaction = True
        
        try:
            yield self
            # Transaction successful, keep changes
            self._transaction_stack.pop()
            self._in_transaction = False
        except Exception as e:
            # Rollback on error
            self.rollback()
            raise e
    
    def rollback(self):
        """Rollback to previous state"""
        if self._transaction_stack:
            previous_state = self._transaction_stack.pop()
            # Restore state
            for key, value in previous_state["state"].items():
                if not key.startswith("_"):
                    setattr(self, key, value)
            self._in_transaction = False
    
    def commit(self):
        """Explicitly commit current transaction"""
        if self._in_transaction and self._transaction_stack:
            self._transaction_stack.pop()
            self._in_transaction = False

# Use transactional session
session = TransactionalSession("trans-001")
session.user_data = {"balance": 1000}

# Successful transaction
with session.transaction():
    session.user_data["balance"] -= 100
    session.user_data["purchases"] = ["item1"]
    # Transaction commits automatically

print(f"Balance after purchase: {session.user_data['balance']}")  # 900

# Failed transaction with rollback
try:
    with session.transaction():
        session.user_data["balance"] -= 2000  # Would go negative
        if session.user_data["balance"] < 0:
            raise ValueError("Insufficient funds")
        session.user_data["purchases"].append("expensive_item")
except ValueError:
    print("Transaction failed")

print(f"Balance after failed transaction: {session.user_data['balance']}")  # Still 900
```

### 2. Distributed State Synchronization

```python
from praisonaiagents import Session
import asyncio
import aioredis
from typing import Dict, Any, Callable

class DistributedSession(Session):
    def __init__(
        self, 
        session_id: str,
        redis_url: str = "redis://localhost:6379",
        sync_interval: float = 1.0,
        **kwargs
    ):
        super().__init__(session_id, **kwargs)
        self.redis_url = redis_url
        self.sync_interval = sync_interval
        self._redis = None
        self._sync_task = None
        self._local_version = 0
        self._remote_version = 0
        self._change_callbacks: List[Callable] = []
    
    async def connect(self):
        """Connect to Redis for state sync"""
        self._redis = await aioredis.create_redis_pool(self.redis_url)
        self._sync_task = asyncio.create_task(self._sync_loop())
        
        # Load initial state
        await self._pull_state()
    
    async def disconnect(self):
        """Disconnect from Redis"""
        if self._sync_task:
            self._sync_task.cancel()
        if self._redis:
            self._redis.close()
            await self._redis.wait_closed()
    
    async def _sync_loop(self):
        """Background sync loop"""
        while True:
            try:
                await asyncio.sleep(self.sync_interval)
                await self._sync_state()
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Sync error: {e}")
    
    async def _sync_state(self):
        """Synchronize state with Redis"""
        # Check remote version
        remote_version = await self._redis.get(f"session:{self.session_id}:version")
        if remote_version:
            remote_version = int(remote_version)
            
            if remote_version > self._remote_version:
                # Pull changes
                await self._pull_state()
            elif self._local_version > self._remote_version:
                # Push changes
                await self._push_state()
    
    async def _pull_state(self):
        """Pull state from Redis"""
        state_data = await self._redis.get(f"session:{self.session_id}:state")
        if state_data:
            state = json.loads(state_data)
            self._apply_remote_state(state)
            self._remote_version = int(await self._redis.get(f"session:{self.session_id}:version"))
            
            # Notify callbacks
            for callback in self._change_callbacks:
                await callback("pull", state)
    
    async def _push_state(self):
        """Push state to Redis"""
        state = self._get_local_state()
        
        # Atomic update with version increment
        pipe = self._redis.pipeline()
        pipe.set(f"session:{self.session_id}:state", json.dumps(state))
        pipe.incr(f"session:{self.session_id}:version")
        await pipe.execute()
        
        self._remote_version = self._local_version
    
    def _get_local_state(self) -> Dict[str, Any]:
        """Get serializable local state"""
        return {
            "session_id": self.session_id,
            "user_id": getattr(self, "user_id", None),
            "data": getattr(self, "data", {}),
            "metadata": {
                "version": self._local_version,
                "updated_at": datetime.datetime.now().isoformat()
            }
        }
    
    def _apply_remote_state(self, state: Dict[str, Any]):
        """Apply remote state to local session"""
        if "data" in state:
            self.data = state["data"]
        if "user_id" in state:
            self.user_id = state["user_id"]
    
    def update_state(self, key: str, value: Any):
        """Update state with version tracking"""
        if not hasattr(self, "data"):
            self.data = {}
        
        self.data[key] = value
        self._local_version += 1
    
    def on_state_change(self, callback: Callable):
        """Register callback for state changes"""
        self._change_callbacks.append(callback)

# Use distributed session
async def distributed_example():
    # Create sessions on different "nodes"
    session1 = DistributedSession("shared-session-001")
    session2 = DistributedSession("shared-session-001")
    
    await session1.connect()
    await session2.connect()
    
    # Update from node 1
    session1.update_state("user_name", "Alice")
    session1.update_state("status", "online")
    
    # Wait for sync
    await asyncio.sleep(2)
    
    # Node 2 sees the updates
    print(f"Node 2 sees: {session2.data}")
    
    # Cleanup
    await session1.disconnect()
    await session2.disconnect()

# Run distributed example
# asyncio.run(distributed_example())
```

## Best Practices

### 1. Session Lifecycle Management

```python
from praisonaiagents import Session
from datetime import datetime, timedelta
import atexit

class ManagedSession(Session):
    """Session with lifecycle management"""
    
    _active_sessions = {}
    
    def __init__(self, session_id: str, ttl_hours: int = 24, **kwargs):
        super().__init__(session_id, **kwargs)
        self.created_at = datetime.now()
        self.last_accessed = datetime.now()
        self.ttl_hours = ttl_hours
        
        # Register session
        ManagedSession._active_sessions[session_id] = self
    
    @classmethod
    def get_or_create(cls, session_id: str, **kwargs) -> "ManagedSession":
        """Get existing session or create new one"""
        if session_id in cls._active_sessions:
            session = cls._active_sessions[session_id]
            session.last_accessed = datetime.now()
            return session
        
        return cls(session_id, **kwargs)
    
    @classmethod
    def cleanup_expired(cls):
        """Remove expired sessions"""
        now = datetime.now()
        expired = []
        
        for sid, session in cls._active_sessions.items():
            if now - session.last_accessed > timedelta(hours=session.ttl_hours):
                expired.append(sid)
        
        for sid in expired:
            session = cls._active_sessions.pop(sid)
            session.cleanup()
    
    def cleanup(self):
        """Cleanup session resources"""
        # Save to persistent storage
        if hasattr(self, 'backend'):
            self.save()
        
        # Clear memory
        if hasattr(self, 'memory'):
            self.memory.clear()
    
    def touch(self):
        """Update last accessed time"""
        self.last_accessed = datetime.now()
    
    def is_expired(self) -> bool:
        """Check if session is expired"""
        return datetime.now() - self.last_accessed > timedelta(hours=self.ttl_hours)

# Register cleanup on exit
atexit.register(lambda: ManagedSession.cleanup_expired())

# Periodic cleanup task
async def session_cleanup_task():
    while True:
        await asyncio.sleep(3600)  # Every hour
        ManagedSession.cleanup_expired()
```

### 2. State Versioning

```python
from praisonaiagents import Session
import hashlib

class VersionedSession(Session):
    """Session with state versioning"""
    
    def __init__(self, session_id: str, **kwargs):
        super().__init__(session_id, **kwargs)
        self.version_history = []
        self.max_versions = 10
    
    def save_version(self, description: str = None):
        """Save current state as a version"""
        state = self.get_state()
        version = {
            "version_id": self._generate_version_id(state),
            "timestamp": datetime.datetime.now().isoformat(),
            "description": description,
            "state": state
        }
        
        self.version_history.append(version)
        
        # Limit version history
        if len(self.version_history) > self.max_versions:
            self.version_history.pop(0)
        
        return version["version_id"]
    
    def restore_version(self, version_id: str):
        """Restore to a specific version"""
        for version in self.version_history:
            if version["version_id"] == version_id:
                self.restore_state(version["state"])
                return True
        return False
    
    def list_versions(self):
        """List available versions"""
        return [
            {
                "version_id": v["version_id"],
                "timestamp": v["timestamp"],
                "description": v["description"]
            }
            for v in self.version_history
        ]
    
    def _generate_version_id(self, state: dict) -> str:
        """Generate unique version ID"""
        state_str = json.dumps(state, sort_keys=True)
        return hashlib.sha256(state_str.encode()).hexdigest()[:8]
    
    def diff_versions(self, version_id1: str, version_id2: str) -> dict:
        """Compare two versions"""
        v1 = next((v for v in self.version_history if v["version_id"] == version_id1), None)
        v2 = next((v for v in self.version_history if v["version_id"] == version_id2), None)
        
        if not v1 or not v2:
            return {"error": "Version not found"}
        
        # Simple diff (in production, use proper diff algorithm)
        return {
            "added": set(v2["state"].keys()) - set(v1["state"].keys()),
            "removed": set(v1["state"].keys()) - set(v2["state"].keys()),
            "modified": [k for k in set(v1["state"].keys()) & set(v2["state"].keys())
                        if v1["state"][k] != v2["state"][k]]
        }
```

### 3. Security and Privacy

```python
from praisonaiagents import Session
from cryptography.fernet import Fernet
import base64

class SecureSession(Session):
    """Session with encryption for sensitive data"""
    
    def __init__(self, session_id: str, encryption_key: bytes = None, **kwargs):
        super().__init__(session_id, **kwargs)
        
        # Generate or use provided encryption key
        if encryption_key:
            self.cipher = Fernet(encryption_key)
        else:
            self.cipher = Fernet(Fernet.generate_key())
        
        self._sensitive_fields = set()
    
    def mark_sensitive(self, field_name: str):
        """Mark a field as sensitive for encryption"""
        self._sensitive_fields.add(field_name)
    
    def set_sensitive_data(self, key: str, value: Any):
        """Set sensitive data (encrypted)"""
        self.mark_sensitive(key)
        
        # Serialize and encrypt
        serialized = json.dumps(value)
        encrypted = self.cipher.encrypt(serialized.encode())
        
        # Store as base64
        setattr(self, key, base64.b64encode(encrypted).decode())
    
    def get_sensitive_data(self, key: str, default=None) -> Any:
        """Get sensitive data (decrypted)"""
        if not hasattr(self, key):
            return default
        
        try:
            # Decode and decrypt
            encrypted = base64.b64decode(getattr(self, key))
            decrypted = self.cipher.decrypt(encrypted)
            return json.loads(decrypted.decode())
        except Exception:
            return default
    
    def save(self):
        """Save session with encrypted sensitive fields"""
        state = {}
        
        for key, value in self.__dict__.items():
            if key.startswith("_"):
                continue
                
            if key in self._sensitive_fields:
                # Already encrypted
                state[key] = value
            else:
                # Regular data
                state[key] = value
        
        state["_sensitive_fields"] = list(self._sensitive_fields)
        return state
    
    def sanitize_for_logging(self) -> dict:
        """Get sanitized state for logging"""
        sanitized = {}
        
        for key, value in self.__dict__.items():
            if key.startswith("_"):
                continue
                
            if key in self._sensitive_fields:
                sanitized[key] = "[REDACTED]"
            else:
                sanitized[key] = value
        
        return sanitized

# Use secure session
secure_session = SecureSession("secure-001")
secure_session.set_sensitive_data("credit_card", "1234-5678-9012-3456")
secure_session.set_sensitive_data("ssn", "123-45-6789")
secure_session.user_name = "John Doe"  # Non-sensitive

# Sensitive data is encrypted in storage
print(f"Stored credit card: {getattr(secure_session, 'credit_card')}")  # Encrypted
print(f"Retrieved credit card: {secure_session.get_sensitive_data('credit_card')}")  # Decrypted

# Safe for logging
print(f"Log data: {secure_session.sanitize_for_logging()}")
```

## Conclusion

Session persistence in PraisonAI provides powerful capabilities for building stateful applications. From simple conversation continuity to complex distributed systems, the session management features enable developers to create sophisticated AI applications that maintain context, track progress, and provide personalized experiences across interactions.

## Next Steps

- Explore [Quality-Based RAG](./quality-based-rag.mdx) for stateful retrieval systems
- Learn about [Graph Memory](./graph-memory-neo4j.mdx) for relationship-aware persistence
- Check out [Approval Systems](./approval-system-human-loop.mdx) for stateful approval workflows