---
title: "Error Handling"
sidebarTitle: "Error Handling"
description: "Handle errors gracefully in the PraisonAI Rust SDK"
icon: "triangle-exclamation"
---

# Error Handling

The Rust SDK uses a unified error type with context support for clear, actionable error messages.

## Quick Start

```rust
use praisonai::{Agent, Result};

#[tokio::main]
async fn main() -> Result<()> {
    let agent = Agent::new()
        .instructions("You are a helpful assistant")
        .build()?;  // Returns Result<Agent>
    
    let response = agent.chat("Hello").await?;  // Returns Result<String>
    
    Ok(())
}
```

## Error Type

All errors in the SDK are represented by the `Error` enum:

```rust
use praisonai::error::Error;

match result {
    Ok(value) => println!("Success: {}", value),
    Err(e) => match e {
        Error::Agent(msg) => println!("Agent error: {}", msg),
        Error::Tool(msg) => println!("Tool error: {}", msg),
        Error::Llm(msg) => println!("LLM error: {}", msg),
        Error::Memory(msg) => println!("Memory error: {}", msg),
        Error::Workflow(msg) => println!("Workflow error: {}", msg),
        Error::Config(msg) => println!("Config error: {}", msg),
        Error::Embedding(msg) => println!("Embedding error: {}", msg),
        Error::Serialization(e) => println!("JSON error: {}", e),
        Error::Yaml(e) => println!("YAML error: {}", e),
        Error::Http(e) => println!("HTTP error: {}", e),
        Error::Io(e) => println!("IO error: {}", e),
        Error::WithContext { context, source } => {
            println!("Error in {}: {}", context, source);
        }
    }
}
```

## Error Variants

| Variant | Description | Common Causes |
|---------|-------------|---------------|
| `Agent` | Agent execution errors | Max iterations exceeded, invalid config |
| `Tool` | Tool execution errors | Tool not found, execution failure |
| `Llm` | LLM provider errors | API errors, invalid responses |
| `Memory` | Memory operation errors | Storage failures |
| `Workflow` | Workflow/handoff errors | Cycle detection, max depth |
| `Config` | Configuration errors | Invalid settings |
| `Embedding` | Embedding errors | Vector operations |
| `Serialization` | JSON parsing errors | Invalid JSON |
| `Yaml` | YAML parsing errors | Invalid YAML |
| `Http` | HTTP request errors | Network issues |
| `Io` | File/IO errors | File not found |
| `WithContext` | Error with added context | Any error with context |

## Creating Errors

```rust
use praisonai::error::Error;

// Helper methods
let err = Error::agent("Max iterations exceeded");
let err = Error::tool("Tool 'search' not found");
let err = Error::llm("API rate limit exceeded");
let err = Error::memory("Failed to store message");
let err = Error::workflow("Workflow execution failed");
let err = Error::config("Invalid model name");
let err = Error::io("File not found");
let err = Error::handoff("Cycle detected: A -> B -> A");
```

## Adding Context

Add context to errors for better debugging:

```rust
use praisonai::error::{Error, ResultExt};

// With error
let error = Error::tool("execution failed")
    .with_context("search_web");
// Output: "search_web: Tool error: execution failed"

// With Result
fn search(query: &str) -> praisonai::Result<String> {
    // ...
}

let result = search("rust")
    .context("searching for rust tutorials")?;
```

## Result Type

The SDK provides a `Result<T>` type alias:

```rust
use praisonai::Result;

fn my_function() -> Result<String> {
    let agent = Agent::new()
        .instructions("Help me")
        .build()?;
    
    agent.chat("Hello").await
}
```

## Error Handling Patterns

### Basic Pattern

```rust
use praisonai::{Agent, Result};

async fn run_agent() -> Result<String> {
    let agent = Agent::new()
        .instructions("Be helpful")
        .build()?;
    
    agent.chat("Hello").await
}

#[tokio::main]
async fn main() {
    match run_agent().await {
        Ok(response) => println!("{}", response),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

### With Context

```rust
use praisonai::error::ResultExt;

async fn process_query(query: &str) -> Result<String> {
    let agent = Agent::new()
        .build()
        .context("building agent")?;
    
    agent.chat(query)
        .await
        .context(format!("processing query: {}", query))
}
```

### Recoverable Errors

```rust
async fn chat_with_retry(agent: &Agent, prompt: &str, max_retries: u32) -> Result<String> {
    let mut last_error = None;
    
    for attempt in 0..max_retries {
        match agent.chat(prompt).await {
            Ok(response) => return Ok(response),
            Err(e) => {
                eprintln!("Attempt {} failed: {}", attempt + 1, e);
                last_error = Some(e);
                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            }
        }
    }
    
    Err(last_error.unwrap_or_else(|| Error::agent("Max retries exceeded")))
}
```

### Fallback Values

```rust
let response = agent.chat("Hello")
    .await
    .unwrap_or_else(|_| "Sorry, I couldn't respond.".to_string());
```

## Integration with std::error

The `Error` type implements `std::error::Error`:

```rust
use std::error::Error as StdError;

fn handle_any_error(e: &dyn StdError) {
    eprintln!("Error: {}", e);
    if let Some(source) = e.source() {
        eprintln!("Caused by: {}", source);
    }
}
```

## Related

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Agent API reference
  </Card>
  <Card title="Tools" icon="wrench" href="/docs/rust/tools">
    Tool error handling
  </Card>
  <Card title="LLM" icon="microchip" href="/docs/rust/llm">
    LLM provider errors
  </Card>
  <Card title="Debugging" icon="bug" href="/docs/rust/debugging">
    Debugging techniques
  </Card>
</CardGroup>
