---
title: "Tracing"
sidebarTitle: "Tracing"
description: "Distributed tracing and observability in the PraisonAI Rust SDK"
icon: "code-branch"
---

# Tracing

The Tracing module provides OpenTelemetry-compatible distributed tracing for agent execution, tool calls, and workflows.

## Quick Start

```rust
use praisonai::trace::{TraceContext, Span, SpanKind};

// Create a trace
let mut ctx = TraceContext::new("agent-workflow");

// Start spans
let agent_span = ctx.start_span("agent-execution", SpanKind::Agent);

// Do work...

// End span
ctx.end_span(&agent_span);

// Export
println!("{}", ctx.to_json());
```

## SpanKind

Categories of spans for different operations:

| Kind | Description |
|------|-------------|
| `Internal` | Internal operations |
| `Llm` | LLM API calls |
| `Tool` | Tool executions |
| `Agent` | Agent processing |
| `Workflow` | Workflow orchestration |
| `Memory` | Memory operations |
| `Network` | Network/API calls |
| `Custom` | Custom operations |

## Span

A unit of work in a trace:

```rust
use praisonai::trace::{Span, SpanKind, SpanEvent};
use std::time::Duration;

// Create a span
let mut span = Span::new("trace-123", "process-request", SpanKind::Agent, Duration::ZERO);

// Set parent
let span = span.with_parent("parent-span-id");

// Add attributes
span.set_attribute("agent_name", "researcher");
span.set_attribute("model", "gpt-4");
span.set_attribute("tokens", 150);

// Add events
let event = SpanEvent::new("tool_called", Duration::from_millis(50))
    .with_attribute("tool", "web_search");
span.add_event(event);

// End the span
span.end(Duration::from_millis(500));
println!("Duration: {:?}", span.duration);

// Mark as error
span.set_error("Request failed: timeout");
```

### SpanStatus

| Status | Description |
|--------|-------------|
| `Unset` | Not yet determined |
| `Ok` | Success |
| `Error` | Failed |

## TraceContext

Manages a complete trace with multiple spans:

```rust
use praisonai::trace::{TraceContext, SpanKind};

let mut ctx = TraceContext::new("my-workflow");

// Nested spans
let workflow_span = ctx.start_span("workflow", SpanKind::Workflow);
    
    let agent_span = ctx.start_span("agent", SpanKind::Agent);
        
        let tool_span = ctx.start_span("search", SpanKind::Tool);
        // ... use tool ...
        ctx.end_span(&tool_span);
        
    ctx.end_span(&agent_span);
    
ctx.end_span(&workflow_span);

// Query spans
println!("Span count: {}", ctx.span_count());
println!("Elapsed: {:?}", ctx.elapsed());

// Get current span
if let Some(span_id) = ctx.current_span_id() {
    println!("Current: {}", span_id);
}

// Add event to current span
ctx.add_event("checkpoint");
ctx.set_attribute("step", 3);

// Get specific span
if let Some(span) = ctx.get_span(&workflow_span) {
    println!("Status: {:?}", span.status);
}

// Export to JSON
let json = ctx.to_json();
```

## TraceExporter

Export traces to different destinations:

```rust
use praisonai::trace::{TraceExporter, ConsoleExporter, JsonFileExporter, TraceContext};

// Console exporter
let console = ConsoleExporter::default();

// JSON file exporter
let file = JsonFileExporter::new("./traces/trace.json");

// Export
let ctx = TraceContext::new("test");
console.export(&ctx)?;
file.export(&ctx)?;
```

### Custom Exporter

```rust
use praisonai::trace::{TraceExporter, TraceContext};

struct MyExporter;

impl TraceExporter for MyExporter {
    fn export(&self, trace: &TraceContext) -> Result<(), Box<dyn std::error::Error>> {
        // Send to your observability backend
        println!("Exporting trace: {}", trace.id);
        for span in trace.spans() {
            println!("  Span: {} ({:?})", span.name, span.duration);
        }
        Ok(())
    }
}
```

## Tracer

Global tracer for managing multiple traces:

```rust
use praisonai::trace::{Tracer, SpanKind, ConsoleExporter};

let tracer = Tracer::new();

// Add exporters
tracer.add_exporter(ConsoleExporter::default());

// Start a trace
let trace_id = tracer.start_trace("my-workflow");

// Add spans
if let Some(span_id) = tracer.start_span(&trace_id, "step-1", SpanKind::Agent) {
    // Do work...
    tracer.end_span(&trace_id, &span_id);
}

// End trace (triggers export)
tracer.end_trace(&trace_id);

println!("Active traces: {}", tracer.trace_count());
```

## ContextEvent

Structured events for replay and debugging:

```rust
use praisonai::trace::{ContextEvent, ContextEventType};

let event = ContextEvent::new(ContextEventType::AgentStart, "agent_start")
    .agent("agent-1", "researcher")
    .input(serde_json::json!("Search for AI news"))
    .metadata("model", serde_json::json!("gpt-4"));

let tool_event = ContextEvent::new(ContextEventType::ToolEnd, "tool_end")
    .tool("web_search")
    .output(serde_json::json!({"results": 10}))
    .duration_ms(2500);
```

### ContextEventType

| Event | Description |
|-------|-------------|
| `AgentStart` | Agent started |
| `AgentEnd` | Agent completed |
| `ToolStart` | Tool call started |
| `ToolEnd` | Tool call completed |
| `LlmStart` | LLM request started |
| `LlmEnd` | LLM response received |
| `MemoryOp` | Memory operation |
| `WorkflowStep` | Workflow step |
| `Error` | Error occurred |
| `Custom` | Custom event |

## ContextTraceEmitter

Emit structured context events:

```rust
use praisonai::trace::{ContextTraceEmitter, ContextListSink};

// With list sink (stores in memory)
let mut emitter = ContextTraceEmitter::with_list_sink();

// Emit events
emitter.agent_start("agent-1", "researcher", "Search for news");
emitter.tool_start("web_search", serde_json::json!({"query": "AI news"}));
emitter.tool_end("web_search", serde_json::json!({"count": 5}), 1500);
emitter.agent_end("agent-1", "researcher", "Found 5 articles", 3000);

// Get events
for event in emitter.events() {
    println!("{:?}: {}", event.event_type, event.name);
}

// Clear
emitter.clear();
```

### Sink Types

```rust
use praisonai::trace::{ContextTraceEmitter, ContextNoOpSink, ContextListSink};

// No-op (zero overhead, production)
let noop = ContextTraceEmitter::noop();

// List (development/debugging)
let list = ContextTraceEmitter::with_list_sink();

// Custom sink
let custom = ContextTraceEmitter::new(ContextListSink::new());
```

## Example: Full Workflow Tracing

```rust
use praisonai::{Agent, Result};
use praisonai::trace::{TraceContext, SpanKind, ConsoleExporter, TraceExporter};

#[tokio::main]
async fn main() -> Result<()> {
    let mut ctx = TraceContext::new("research-workflow");
    
    // Workflow span
    let workflow = ctx.start_span("research", SpanKind::Workflow);
    
        // Agent span
        let agent = ctx.start_span("researcher-agent", SpanKind::Agent);
        ctx.set_attribute("model", "gpt-4");
        
            // Tool span
            let tool = ctx.start_span("web-search", SpanKind::Tool);
            ctx.add_event("search_started");
            // Simulate tool work
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
            ctx.add_event("search_completed");
            ctx.end_span(&tool);
            
            // LLM span
            let llm = ctx.start_span("generate-response", SpanKind::Llm);
            tokio::time::sleep(std::time::Duration::from_millis(50)).await;
            ctx.set_attribute("tokens", 150);
            ctx.end_span(&llm);
            
        ctx.end_span(&agent);
        
    ctx.end_span(&workflow);
    
    // Export
    ConsoleExporter::default().export(&ctx)?;
    
    Ok(())
}
```

## Related

<CardGroup cols={2}>
  <Card title="Telemetry" icon="chart-line" href="/docs/rust/telemetry">
    Performance monitoring
  </Card>
  <Card title="Streaming" icon="wave-pulse" href="/docs/rust/streaming">
    Real-time events
  </Card>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Agent API
  </Card>
  <Card title="Hooks" icon="webhook" href="/docs/rust/hooks">
    Event hooks
  </Card>
</CardGroup>
