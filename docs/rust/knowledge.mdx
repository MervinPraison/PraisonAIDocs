---
title: "Knowledge"
sidebarTitle: "Knowledge"
description: "Manage documents and semantic search in the PraisonAI Rust SDK"
icon: "book-open-reader"
---

# Knowledge

The Knowledge system provides document storage, chunking, vector search, and retrieval-augmented generation (RAG) capabilities.

## Quick Start

```rust
use praisonai::knowledge::{Knowledge, KnowledgeConfig, Document};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut knowledge = Knowledge::new()
        .config(KnowledgeConfig::default())
        .build()?;
    
    // Add content
    knowledge.add("Rust is a systems programming language", None)?;
    
    // Add a document
    let doc = Document::new("PraisonAI is an AI agent framework")
        .source("https://docs.praisonai.com")
        .metadata("category", "documentation");
    knowledge.add_document(doc)?;
    
    Ok(())
}
```

## Document

Represents a document in the knowledge base:

```rust
use praisonai::knowledge::Document;

let doc = Document::new("Document content here")
    .source("https://example.com/doc")
    .filename("readme.md")
    .metadata("author", "Alice")
    .metadata("category", "tutorial");

println!("ID: {}", doc.id);
println!("Content: {}", doc.content);
println!("Source: {:?}", doc.source);
```

### Document Properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | String | Unique document ID |
| `content` | String | Document content |
| `metadata` | HashMap | Key-value metadata |
| `source` | Option\<String\> | Source URL/path |
| `filename` | Option\<String\> | Original filename |
| `created_at` | Option\<u64\> | Creation timestamp |
| `updated_at` | Option\<u64\> | Update timestamp |

## Search Results

### SearchResultItem

Individual search result:

```rust
use praisonai::knowledge::SearchResultItem;

let item = SearchResultItem::new("doc-123", "Result text", 0.95);

println!("ID: {}", item.id);
println!("Text: {}", item.text);
println!("Score: {}", item.score);
```

### SearchResult

Container for search results:

```rust
use praisonai::knowledge::SearchResult;

let result = SearchResult::new("search query", vec![/* items */]);

println!("Query: {}", result.query);
println!("Count: {}", result.len());
println!("Empty: {}", result.is_empty());
```

## Vector Store

### VectorStoreProtocol

Protocol for vector store implementations:

```rust
use praisonai::knowledge::{VectorStoreProtocol, VectorRecord, SearchResultItem};
use async_trait::async_trait;

#[async_trait]
pub trait VectorStoreProtocol: Send + Sync {
    async fn add(&mut self, record: VectorRecord) -> Result<String>;
    async fn search(&self, query_embedding: &[f32], limit: usize) -> Result<Vec<SearchResultItem>>;
    async fn get(&self, id: &str) -> Result<Option<VectorRecord>>;
    async fn delete(&mut self, id: &str) -> Result<bool>;
    async fn get_all(&self, limit: usize) -> Result<Vec<VectorRecord>>;
    async fn clear(&mut self) -> Result<()>;
    fn len(&self) -> usize;
}
```

### InMemoryVectorStore

Default in-memory implementation:

```rust
use praisonai::knowledge::{InMemoryVectorStore, VectorRecord, VectorStoreProtocol};

let mut store = InMemoryVectorStore::new();

// Add a record
let record = VectorRecord::new("doc-1", "Sample text", vec![0.1, 0.2, 0.3]);
store.add(record).await?;

// Search
let results = store.search(&[0.1, 0.2, 0.3], 10).await?;

println!("Records: {}", store.len());
```

## Chunking

Split documents into smaller pieces:

```rust
use praisonai::knowledge::{Chunking, ChunkingConfig, ChunkingStrategy};

let config = ChunkingConfig {
    chunk_size: 1000,
    chunk_overlap: 200,
    strategy: ChunkingStrategy::FixedSize,
};

let chunker = Chunking::new(config);
let chunks = chunker.chunk("Your long document text here...");

for (i, chunk) in chunks.iter().enumerate() {
    println!("Chunk {}: {} chars", i, chunk.len());
}
```

### Chunking Strategies

| Strategy | Description |
|----------|-------------|
| `FixedSize` | Fixed character count with overlap |
| `Sentence` | Split by sentence boundaries |
| `Paragraph` | Split by paragraph (double newline) |
| `Semantic` | Semantic-aware splitting |

## Retrieval

### RetrievalStrategy

Control how documents are retrieved:

```rust
use praisonai::knowledge::RetrievalStrategy;

// Simple vector similarity
RetrievalStrategy::Similarity

// Keyword-based search
RetrievalStrategy::Keyword

// Hybrid (similarity + keyword)
RetrievalStrategy::Hybrid

// Multi-query decomposition
RetrievalStrategy::MultiQuery
```

### RetrieverProtocol

Protocol for custom retrievers:

```rust
use praisonai::knowledge::{RetrieverProtocol, RetrievalResult, RetrievalStrategy};

#[async_trait]
pub trait RetrieverProtocol: Send + Sync {
    async fn retrieve(&self, query: &str, limit: usize) -> Result<RetrievalResult>;
    fn strategy(&self) -> RetrievalStrategy;
}
```

## Reranking

Rerank search results for better relevance:

```rust
use praisonai::knowledge::{SimpleReranker, RerankerProtocol};

let reranker = SimpleReranker::new();

let reranked = reranker.rerank("query", results, 5).await?;
println!("Top result: {}", reranked.items[0].text);
```

## Knowledge Configuration

Configure the knowledge system:

```rust
use praisonai::knowledge::{KnowledgeConfig, ChunkingConfig, RetrievalStrategy};

let config = KnowledgeConfig::new()
    .chunking(ChunkingConfig {
        chunk_size: 500,
        chunk_overlap: 100,
        strategy: ChunkingStrategy::Sentence,
    })
    .retrieval_strategy(RetrievalStrategy::Hybrid)
    .default_limit(20)
    .enable_reranking(true)
    .user_id("user-123")
    .agent_id("research-agent");

let knowledge = Knowledge::new()
    .config(config)
    .build()?;
```

### Configuration Options

| Option | Type | Description |
|--------|------|-------------|
| `chunking` | ChunkingConfig | Chunking settings |
| `retrieval_strategy` | RetrievalStrategy | Search strategy |
| `default_limit` | usize | Default result limit |
| `enable_reranking` | bool | Enable result reranking |
| `user_id` | Option\<String\> | Filter by user |
| `agent_id` | Option\<String\> | Filter by agent |

## Example: RAG Agent

```rust
use praisonai::{Agent, tool, Result};
use praisonai::knowledge::{Knowledge, KnowledgeConfig};

// Create knowledge base
let mut knowledge = Knowledge::new()
    .config(KnowledgeConfig::default())
    .build()?;

// Add documents
knowledge.add("Rust was created by Graydon Hoare", None)?;
knowledge.add("Rust 1.0 was released in 2015", None)?;
knowledge.add("Rust is known for memory safety", None)?;

// Create a tool that searches knowledge
#[tool(description = "Search the knowledge base")]
async fn search_docs(query: String) -> String {
    // In practice, you would use the knowledge instance here
    format!("Searching for: {}", query)
}

let agent = Agent::new()
    .instructions("Answer questions using the search_docs tool")
    .tool(SearchDocs)
    .build()?;

let answer = agent.chat("When was Rust released?").await?;
```

## Related

<CardGroup cols={2}>
  <Card title="Memory" icon="brain" href="/docs/rust/memory">
    Conversation memory
  </Card>
  <Card title="RAG" icon="database" href="/docs/concepts/rag">
    RAG concepts
  </Card>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Agent API
  </Card>
  <Card title="Tools" icon="wrench" href="/docs/rust/tools">
    Create search tools
  </Card>
</CardGroup>
