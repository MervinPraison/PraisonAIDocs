---
title: "Agent Team"
sidebarTitle: "Agent Team"
description: "Coordinate multiple agents in the PraisonAI Rust SDK"
icon: "users"
---

# Agent Team

Agent Team coordinates multiple agents to work together on complex tasks. Supports sequential, parallel, and hierarchical execution.

## Quick Start

```rust
use praisonai::{Agent, AgentTeam, Process, Result};

#[tokio::main]
async fn main() -> Result<()> {
    let researcher = Agent::new()
        .name("researcher")
        .instructions("Research topics thoroughly")
        .build()?;
    
    let writer = Agent::new()
        .name("writer")
        .instructions("Write clear, engaging content")
        .build()?;
    
    let team = AgentTeam::new()
        .agent(researcher)
        .agent(writer)
        .process(Process::Sequential)
        .build();
    
    let result = team.start("Write an article about AI safety").await?;
    println!("{}", result);
    
    Ok(())
}
```

## Building Teams

Use the fluent builder pattern:

```rust
use praisonai::{AgentTeam, Agent, Process};

let team = AgentTeam::new()
    .agent(agent1)                    // Add agent
    .agent(agent2)                    // Add another
    .agent_arc(shared_agent)          // Add Arc<Agent>
    .process(Process::Sequential)     // Execution mode
    .verbose(true)                    // Enable logging
    .build();
```

### Builder Methods

| Method | Description |
|--------|-------------|
| `agent(Agent)` | Add an agent |
| `agent_arc(Arc<Agent>)` | Add shared agent |
| `process(Process)` | Set execution mode |
| `verbose(bool)` | Enable verbose output |
| `build()` | Create the team |

## Process Types

Control how agents execute:

```rust
use praisonai::workflows::Process;

// Execute agents one after another, passing output to next
Process::Sequential

// Execute all agents simultaneously
Process::Parallel

// Manager-based execution with validation
Process::Hierarchical
```

### Sequential Process

Agents run in order, each receiving the previous agent's output:

```rust
let team = AgentTeam::new()
    .agent(researcher)  // Runs first: researches topic
    .agent(writer)      // Runs second: receives research, writes article
    .agent(editor)      // Runs third: receives article, edits
    .process(Process::Sequential)
    .build();

let final_article = team.run("Write about Rust").await?;
```

### Parallel Process

All agents work on the same task simultaneously:

```rust
let team = AgentTeam::new()
    .agent(analyst_1)
    .agent(analyst_2)
    .agent(analyst_3)
    .process(Process::Parallel)
    .build();

// All analysts work in parallel, outputs are combined
let combined_analysis = team.run("Analyze market trends").await?;
```

### Hierarchical Process

Manager-based execution for complex workflows:

```rust
let team = AgentTeam::new()
    .agent(manager)
    .agent(worker_1)
    .agent(worker_2)
    .process(Process::Hierarchical)
    .build();

let result = team.start("Complete this project").await?;
```

## Running Teams

Two equivalent methods:

```rust
// Primary method
let result = team.start("Your task").await?;

// Alias
let result = team.run("Your task").await?;
```

## WorkflowContext

Context passed between agents:

```rust
use praisonai::workflows::WorkflowContext;

let mut ctx = WorkflowContext::new();

// Set variables
ctx.set("topic", "AI safety");
ctx.set("style", "technical");

// Get variables
if let Some(topic) = ctx.get("topic") {
    println!("Topic: {}", topic);
}

// Results accumulate automatically
let last = ctx.last_result();
```

## StepResult

Results from individual agent steps:

```rust
use praisonai::workflows::StepResult;

// Success
let success = StepResult::success("researcher", "Research findings...");
assert!(success.success);

// Failure
let failure = StepResult::failure("analyzer", "API rate limit");
assert!(!failure.success);
assert!(failure.error.is_some());
```

## Team Properties

```rust
let team = AgentTeam::new()
    .agent(agent1)
    .agent(agent2)
    .build();

println!("Agents: {}", team.len());      // 2
println!("Empty: {}", team.is_empty());  // false
println!("Verbose: {}", team.is_verbose());
```

## Example: Content Pipeline

```rust
use praisonai::{Agent, AgentTeam, Process, Result};

#[tokio::main]
async fn main() -> Result<()> {
    // Researcher finds information
    let researcher = Agent::new()
        .name("researcher")
        .instructions(r#"
            You research topics thoroughly.
            Find key facts, statistics, and insights.
            Output structured research notes.
        "#)
        .build()?;
    
    // Writer creates content
    let writer = Agent::new()
        .name("writer")
        .instructions(r#"
            You write engaging content based on research.
            Create clear, well-structured articles.
            Use the research provided to support your writing.
        "#)
        .build()?;
    
    // Editor polishes final output
    let editor = Agent::new()
        .name("editor")
        .instructions(r#"
            You edit and polish content.
            Fix grammar, improve clarity, ensure consistency.
            Make the content publication-ready.
        "#)
        .build()?;
    
    let pipeline = AgentTeam::new()
        .agent(researcher)
        .agent(writer)
        .agent(editor)
        .process(Process::Sequential)
        .verbose(true)
        .build();
    
    let article = pipeline.run(
        "Create an article about the future of renewable energy"
    ).await?;
    
    println!("{}", article);
    Ok(())
}
```

## Related

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Create individual agents
  </Card>
  <Card title="Agent Flow" icon="diagram-project" href="/docs/rust/agent-flow">
    Complex workflow patterns
  </Card>
  <Card title="Handoffs" icon="arrow-right-arrow-left" href="/docs/rust/handoffs">
    Dynamic agent transfers
  </Card>
  <Card title="Process" icon="list-check" href="/docs/concepts/process">
    Process types explained
  </Card>
</CardGroup>
