---
title: "Hooks"
sidebarTitle: "Hooks"
description: "Intercept and modify agent behavior with the hook system in the PraisonAI Rust SDK"
icon: "anchor"
---

# Hooks

Hooks enable you to intercept, modify, or block agent behavior at various lifecycle points. Unlike callbacks (for UI events), hooks can control tool execution and agent decisions.

## Quick Start

```rust
use praisonai::{Agent, hooks::{HookRegistry, HookEvent, HookResult}};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut hooks = HookRegistry::new();
    
    // Block dangerous tools
    hooks.add_hook(HookEvent::BeforeTool, |input| {
        if input.tool_name.as_deref() == Some("delete_file") {
            return HookResult::deny("File deletion is not allowed");
        }
        HookResult::allow()
    });
    
    let agent = Agent::new("assistant")
        .hooks(hooks)
        .build()?;
    
    Ok(())
}
```

## Hook Events

| Event | Description |
|-------|-------------|
| `BeforeTool` | Before tool execution (can block) |
| `AfterTool` | After tool execution |
| `BeforeAgent` | Before agent processes a message |
| `AfterAgent` | After agent processes a message |
| `BeforeLlm` | Before LLM API call |
| `AfterLlm` | After LLM API call |
| `SessionStart` | When session begins |
| `SessionEnd` | When session ends |
| `OnError` | When an error occurs |
| `OnRetry` | When an operation is retried |
| `OnInit` | On initialization |
| `OnShutdown` | On shutdown |

## HookResult

Control execution flow with decisions:

```rust
use praisonai::hooks::HookResult;

// Allow the operation
HookResult::allow()
HookResult::allow_with_reason("Approved by policy")

// Deny the operation (can be retried)
HookResult::deny("Operation not permitted")

// Block the operation (stronger than deny)
HookResult::block("Blocked by security policy")

// Ask for user confirmation
HookResult::ask("This requires approval")
```

### Checking Results

```rust
let result = HookResult::deny("Not allowed");

if result.is_allowed() {
    // Proceed with operation
} else if result.is_denied() {
    // Handle denial
    println!("Denied: {:?}", result.reason);
}
```

## HookInput

Context passed to hooks:

```rust
use praisonai::hooks::{HookInput, HookEvent};
use serde_json::json;

let input = HookInput::new(HookEvent::BeforeTool, "session-123")
    .with_agent("my-agent")
    .with_tool("search", json!({"query": "rust"}))
    .with_message("User message")
    .with_extra("custom_key", json!("custom_value"));

// Access fields
println!("Session: {}", input.session_id);
println!("Event: {}", input.event_name);
println!("Agent: {:?}", input.agent_name);
println!("Tool: {:?}", input.tool_name);
println!("Args: {:?}", input.tool_args);
```

### HookInput Fields

| Field | Type | Description |
|-------|------|-------------|
| `session_id` | `String` | Session identifier |
| `event_name` | `String` | Event type name |
| `timestamp` | `String` | ISO 8601 timestamp |
| `agent_name` | `Option<String>` | Agent name |
| `tool_name` | `Option<String>` | Tool being called |
| `tool_args` | `Option<Value>` | Tool arguments |
| `message` | `Option<String>` | Message content |
| `error` | `Option<String>` | Error message |
| `extra` | `HashMap<String, Value>` | Custom data |

## HookRegistry

Manage and execute hooks:

```rust
use praisonai::hooks::{HookRegistry, HookEvent, HookResult};

let mut registry = HookRegistry::new();

// Add hooks
registry.add_hook(HookEvent::BeforeTool, |input| {
    println!("Tool: {:?}", input.tool_name);
    HookResult::allow()
});

registry.add_hook(HookEvent::OnError, |input| {
    eprintln!("Error: {:?}", input.error);
    HookResult::allow()
});

// Check if hooks exist
if registry.has_hooks(HookEvent::BeforeTool) {
    println!("Hooks registered: {}", registry.hook_count(HookEvent::BeforeTool));
}

// Execute hooks
let input = HookInput::new(HookEvent::BeforeTool, "session-1")
    .with_tool("search", serde_json::json!({}));
let result = registry.execute(HookEvent::BeforeTool, &input);
```

## Pattern Matching

Match specific tools or patterns:

```rust
// Match specific tool
registry.add_hook_with_matcher(
    HookEvent::BeforeTool,
    "delete_file",
    |_| HookResult::deny("Deletion blocked")
);

// Match pattern with wildcard
registry.add_hook_with_matcher(
    HookEvent::BeforeTool,
    "write_*",  // Matches write_file, write_db, etc.
    |_| HookResult::ask("Write operations require approval")
);

// The hook only triggers for matching tools
let input = HookInput::new(HookEvent::BeforeTool, "s1")
    .with_tool("read_file", serde_json::json!({}));
let result = registry.execute(HookEvent::BeforeTool, &input);
assert!(result.is_allowed());  // read_file doesn't match write_*
```

## HookRunner

High-level hook execution:

```rust
use praisonai::hooks::{HookRegistry, HookRunner, HookEvent, HookResult};

let mut registry = HookRegistry::new();
registry.add_hook(HookEvent::BeforeTool, |_| HookResult::allow());

let runner = HookRunner::new(registry);

// Run before-tool hooks
let result = runner.before_tool(
    "session-1",
    "search",
    serde_json::json!({"query": "rust"})
)?;

// Run after-tool hooks
runner.after_tool(
    "session-1",
    "search",
    serde_json::json!({"results": []})
)?;

// Run agent hooks
runner.before_agent("session-1", "assistant", "Hello")?;
runner.after_agent("session-1", "assistant", "Hi there!")?;

// Run error hooks
runner.on_error("session-1", "Connection timeout")?;
```

## Common Patterns

### Security Policy

```rust
registry.add_hook(HookEvent::BeforeTool, |input| {
    let dangerous_tools = ["delete_file", "execute_code", "sudo"];
    
    if let Some(tool) = &input.tool_name {
        if dangerous_tools.contains(&tool.as_str()) {
            return HookResult::block("Security policy: tool not allowed");
        }
    }
    HookResult::allow()
});
```

### Audit Logging

```rust
registry.add_hook(HookEvent::AfterTool, |input| {
    println!(
        "[AUDIT] Tool: {:?}, Args: {:?}, Time: {}",
        input.tool_name,
        input.tool_args,
        input.timestamp
    );
    HookResult::allow()
});
```

### Rate Limiting

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let call_count = Arc::new(AtomicUsize::new(0));
let counter = call_count.clone();

registry.add_hook(HookEvent::BeforeTool, move |_| {
    let count = counter.fetch_add(1, Ordering::SeqCst);
    if count >= 100 {
        return HookResult::deny("Rate limit exceeded");
    }
    HookResult::allow()
});
```

### Input Validation

```rust
registry.add_hook_with_matcher(
    HookEvent::BeforeTool,
    "send_email",
    |input| {
        if let Some(args) = &input.tool_args {
            let to = args["to"].as_str().unwrap_or("");
            if !to.contains('@') {
                return HookResult::deny("Invalid email address");
            }
        }
        HookResult::allow()
    }
);
```

## Related

<CardGroup cols={2}>
  <Card title="Guardrails" icon="shield" href="/docs/rust/guardrails">
    Policy-based guardrails
  </Card>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Create agents with hooks
  </Card>
  <Card title="Tools" icon="wrench" href="/docs/rust/tools">
    Tool system
  </Card>
  <Card title="Events" icon="bell" href="/docs/rust/events">
    Event system
  </Card>
</CardGroup>
