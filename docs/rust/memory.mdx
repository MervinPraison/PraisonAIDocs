---
title: "Memory"
sidebarTitle: "Memory"
description: "Conversation memory and history management in the PraisonAI Rust SDK"
icon: "brain"
---

# Memory

The Memory system enables agents to maintain conversation history and recall past interactions. It supports both short-term (in-memory) and long-term (persistent) storage.

## Quick Start

```rust
use praisonai::{Agent, MemoryConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let agent = Agent::new("assistant")
        .instructions("You are a helpful assistant")
        .memory(MemoryConfig::default())  // Enable memory
        .build()?;
    
    // Agent remembers previous exchanges
    agent.run("My name is Alice").await?;
    agent.run("What's my name?").await?;  // Knows it's Alice
    
    Ok(())
}
```

## MemoryConfig

Configure memory behavior:

```rust
use praisonai::MemoryConfig;

let config = MemoryConfig {
    use_short_term: true,  // Enable conversation history
    use_long_term: false,  // Disable persistent memory
    max_messages: 50,      // Keep last 50 messages
};
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `use_short_term` | `bool` | `true` | Enable conversation history |
| `use_long_term` | `bool` | `false` | Enable persistent memory |
| `max_messages` | `usize` | `100` | Maximum messages to keep |

## ConversationHistory

Direct conversation history management:

```rust
use praisonai::memory::ConversationHistory;
use praisonai::llm::Message;

let mut history = ConversationHistory::new(50);

// Add messages
history.add(Message::system("You are helpful"));
history.add(Message::user("Hello"));
history.add(Message::assistant("Hi there!"));

// Access messages
println!("Messages: {}", history.len());       // 3
let messages = history.messages();              // Vec<Message>

// Clear history
history.clear();
assert!(history.is_empty());
```

### Automatic Trimming

When history exceeds `max_messages`, older messages are removed while preserving system messages:

```rust
let mut history = ConversationHistory::new(3);

history.add(Message::system("System instruction"));  // Protected
history.add(Message::user("Message 1"));
history.add(Message::assistant("Response 1"));
history.add(Message::user("Message 2"));
history.add(Message::assistant("Response 2"));

// System message preserved, oldest user/assistant removed
assert_eq!(history.len(), 3);
assert!(history.messages()[0].role == Role::System);
```

## MemoryAdapter Trait

Implement custom memory backends:

```rust
use praisonai::memory::MemoryAdapter;
use praisonai::llm::Message;
use async_trait::async_trait;

struct RedisMemoryAdapter {
    // Redis client...
}

#[async_trait]
impl MemoryAdapter for RedisMemoryAdapter {
    async fn store_short_term(&mut self, message: Message) -> Result<()> {
        // Store in Redis
        Ok(())
    }
    
    async fn search_short_term(&self, query: &str, limit: usize) -> Result<Vec<Message>> {
        // Search Redis
        Ok(vec![])
    }
    
    async fn get_short_term(&self) -> Result<Vec<Message>> {
        // Get all from Redis
        Ok(vec![])
    }
    
    async fn clear_short_term(&mut self) -> Result<()> {
        // Clear Redis
        Ok(())
    }
    
    // Optional: Long-term memory
    async fn store_long_term(&mut self, text: &str, metadata: Option<Value>) -> Result<()> {
        // Store with embeddings for semantic search
        Ok(())
    }
    
    async fn search_long_term(&self, query: &str, limit: usize) -> Result<Vec<String>> {
        // Semantic search
        Ok(vec![])
    }
}
```

## Built-in Adapters

### InMemoryAdapter

Default in-memory storage (no persistence):

```rust
use praisonai::memory::InMemoryAdapter;

let adapter = InMemoryAdapter::new(100);  // Max 100 messages

// Or use default (100 messages)
let adapter = InMemoryAdapter::default();
```

## Memory Manager

High-level memory operations:

```rust
use praisonai::memory::{Memory, InMemoryAdapter};
use praisonai::MemoryConfig;

// Create with in-memory adapter
let mut memory = Memory::in_memory(MemoryConfig::default());

// Or with custom adapter
let adapter = InMemoryAdapter::new(50);
let mut memory = Memory::new(adapter, MemoryConfig::default());

// Store messages
memory.store(Message::user("Hello")).await?;
memory.store(Message::assistant("Hi there!")).await?;

// Get conversation history
let history = memory.history().await?;
println!("History: {:?}", history);

// Search memory
let results = memory.search("hello", 10).await?;

// Clear memory
memory.clear().await?;
```

## Using with Agents

```rust
use praisonai::{Agent, MemoryConfig};

// Default memory
let agent = Agent::new("assistant")
    .memory(MemoryConfig::default())
    .build()?;

// Custom memory config
let agent = Agent::new("assistant")
    .memory(MemoryConfig {
        use_short_term: true,
        use_long_term: false,
        max_messages: 200,
    })
    .build()?;

// Multi-turn conversation
agent.run("Remember: my favorite color is blue").await?;
agent.run("What's my favorite color?").await?;
// Agent: "Your favorite color is blue"
```

## Example: Conversation Bot

```rust
use praisonai::{Agent, MemoryConfig, Result};
use std::io::{self, Write};

#[tokio::main]
async fn main() -> Result<()> {
    let agent = Agent::new("chatbot")
        .instructions("You are a friendly chatbot. Remember user preferences.")
        .memory(MemoryConfig {
            max_messages: 100,
            ..Default::default()
        })
        .build()?;
    
    println!("Chatbot ready! Type 'quit' to exit.\n");
    
    loop {
        print!("You: ");
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim();
        
        if input == "quit" {
            break;
        }
        
        let response = agent.run(input).await?;
        println!("Bot: {}\n", response);
    }
    
    Ok(())
}
```

## Related

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Create agents with memory
  </Card>
  <Card title="Sessions" icon="clock-rotate-left" href="/docs/rust/sessions">
    Persistent session management
  </Card>
  <Card title="Knowledge" icon="book" href="/docs/rust/knowledge">
    Add external knowledge sources
  </Card>
  <Card title="RAG" icon="magnifying-glass" href="/docs/rust/rag">
    Retrieval-augmented generation
  </Card>
</CardGroup>
