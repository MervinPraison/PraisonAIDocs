---
title: "MCP Integration"
sidebarTitle: "MCP"
description: "Model Context Protocol integration in the PraisonAI Rust SDK"
icon: "plug"
---

# MCP Integration

The Model Context Protocol (MCP) enables agents to connect to external tools, resources, and prompts via standardized protocols.

## Quick Start

```rust
use praisonai::mcp::{MCP, MCPConfig, TransportConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut mcp = MCP::new()
        .name("my-mcp")
        .server("npx", &["-y", "@anthropic/mcp-server-memory"])
        .build()?;
    
    // Connect
    mcp.connect().await?;
    
    // List available tools
    let tools = mcp.list_tools().await?;
    for tool in tools {
        println!("{}: {}", tool.name, tool.description);
    }
    
    // Disconnect
    mcp.disconnect().await?;
    
    Ok(())
}
```

## Transport Types

MCP supports multiple transport protocols:

```rust
use praisonai::mcp::TransportType;

TransportType::Stdio      // Subprocess (default)
TransportType::Sse        // Server-Sent Events
TransportType::HttpStream // Streamable HTTP
TransportType::WebSocket  // WebSocket
```

## Transport Configuration

### Stdio (Subprocess)

For local MCP servers:

```rust
use praisonai::mcp::TransportConfig;

// Memory server
let transport = TransportConfig::stdio("npx", &["-y", "@anthropic/mcp-server-memory"]);

// With environment variables
let transport = TransportConfig::stdio("npx", &["-y", "@modelcontextprotocol/server-fetch"])
    .env("API_KEY", "sk-...")
    .timeout(60);
```

### HTTP

For remote MCP servers:

```rust
use praisonai::mcp::TransportConfig;

let transport = TransportConfig::http("https://mcp.example.com/api")
    .header("Authorization", "Bearer token")
    .timeout(30);
```

### WebSocket

For real-time connections:

```rust
use praisonai::mcp::TransportConfig;

let transport = TransportConfig::websocket("wss://mcp.example.com/ws")
    .header("X-API-Key", "key");
```

## MCP Configuration

Full configuration options:

```rust
use praisonai::mcp::{MCPConfig, TransportConfig, SecurityConfig};

let config = MCPConfig::new("my-server")
    .transport(TransportConfig::stdio("npx", &["-y", "@anthropic/mcp-server"]))
    .security(SecurityConfig::permissive())
    .debug(true);

let mcp = MCP::new()
    .config(config)
    .build()?;
```

## Security Configuration

Control MCP server permissions:

```rust
use praisonai::mcp::SecurityConfig;

// Permissive (allow all)
let security = SecurityConfig::permissive();

// Restrictive (deny all)
let security = SecurityConfig::restrictive();

// Custom
let security = SecurityConfig::default()
    .allow_fs(true)
    .allow_network(true)
    .allowed_host("api.example.com")
    .allowed_path("/tmp");
```

### Security Options

| Option | Description |
|--------|-------------|
| `allow_fs` | Allow file system access |
| `allow_network` | Allow network requests |
| `allow_env` | Allow environment access |
| `allowed_hosts` | Allowed network hosts |
| `allowed_paths` | Allowed file paths |

## Tools

### MCPTool

MCP tool definition:

```rust
use praisonai::mcp::MCPTool;
use serde_json::json;

let tool = MCPTool::new("web_search", "Search the web")
    .input_schema(json!({
        "type": "object",
        "properties": {
            "query": {"type": "string", "description": "Search query"}
        },
        "required": ["query"]
    }));
```

### Calling Tools

Execute MCP tools:

```rust
use praisonai::mcp::{MCP, MCPCall};
use serde_json::json;

let mut mcp = MCP::new()
    .server("npx", &["-y", "@anthropic/mcp-server-memory"])
    .build()?;

mcp.connect().await?;

// Create tool call
let call = MCPCall::new("store_memory", json!({
    "key": "user_name",
    "value": "Alice"
}));

// Execute
let result = mcp.call_tool(call).await?;

// Handle result
for content in result.content {
    match content {
        MCPContent::Text { text } => println!("{}", text),
        MCPContent::Image { data, mime_type } => println!("Image: {}", mime_type),
        MCPContent::Resource { uri, text } => println!("Resource: {}", uri),
    }
}
```

## Resources

Access MCP resources:

```rust
use praisonai::mcp::{MCP, MCPResource};

let mut mcp = /* ... */;
mcp.connect().await?;

// List resources
let resources = mcp.list_resources().await?;
for resource in resources {
    println!("{}: {}", resource.name, resource.uri);
}

// Read a resource
let content = mcp.read_resource("file://data/config.json").await?;
```

### MCPResource

Resource definition:

```rust
use praisonai::mcp::MCPResource;

let resource = MCPResource::new("file://docs/readme.md", "README");
```

## Prompts

Access MCP prompt templates:

```rust
use std::collections::HashMap;

let mut mcp = /* ... */;
mcp.connect().await?;

// List prompts
let prompts = mcp.list_prompts().await?;

// Get a prompt with arguments
let mut args = HashMap::new();
args.insert("topic".to_string(), "Rust programming".to_string());

let prompt = mcp.get_prompt("explain_topic", args).await?;
```

## MCP Server

Expose your own tools as an MCP server:

```rust
use praisonai::mcp::{MCPServer, MCPTool, MCPResource};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut server = MCPServer::new("my-tools");
    
    // Register tools
    server.register_tool(
        MCPTool::new("calculate", "Perform calculations")
            .input_schema(json!({
                "type": "object",
                "properties": {
                    "expression": {"type": "string"}
                }
            }))
    );
    
    // Register resources
    server.register_resource(
        MCPResource::new("file://data/config", "Configuration")
    );
    
    // Start server
    server.start().await?;
    
    println!("Server running with {} tools", server.tools().len());
    
    Ok(())
}
```

## Connection Status

Monitor connection state:

```rust
use praisonai::mcp::ConnectionStatus;

let mcp = MCP::new().build()?;

match mcp.status() {
    ConnectionStatus::Disconnected => println!("Not connected"),
    ConnectionStatus::Connecting => println!("Connecting..."),
    ConnectionStatus::Connected => println!("Connected"),
    ConnectionStatus::Error => println!("Error state"),
}

// Check if connected
if mcp.is_connected() {
    // Safe to call tools
}
```

## Example: Agent with MCP Tools

```rust
use praisonai::{Agent, Result};
use praisonai::mcp::{MCP, MCPCall};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<()> {
    // Set up MCP client
    let mut mcp = MCP::new()
        .name("memory-server")
        .server("npx", &["-y", "@anthropic/mcp-server-memory"])
        .build()?;
    
    mcp.connect().await?;
    
    // List available tools
    let tools = mcp.list_tools().await?;
    println!("Available MCP tools:");
    for tool in &tools {
        println!("  - {}: {}", tool.name, tool.description);
    }
    
    // Use MCP tools in your agent workflow
    let store_call = MCPCall::new("store_memory", json!({
        "key": "project_notes",
        "value": "Working on PraisonAI documentation"
    }));
    
    let result = mcp.call_tool(store_call).await?;
    println!("Stored memory");
    
    // Clean up
    mcp.disconnect().await?;
    
    Ok(())
}
```

## Related

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Agent API reference
  </Card>
  <Card title="Tools" icon="wrench" href="/docs/rust/tools">
    Native tools
  </Card>
  <Card title="MCP Concepts" icon="book" href="/docs/concepts/mcp">
    MCP overview
  </Card>
  <Card title="Configuration" icon="gear" href="/docs/rust/configuration">
    SDK configuration
  </Card>
</CardGroup>
