---
title: "Streaming"
sidebarTitle: "Streaming"
description: "Stream LLM responses in real-time in the PraisonAI Rust SDK"
icon: "wave-pulse"
---

# Streaming

Stream LLM responses token-by-token for responsive UIs. Track timing metrics, handle callbacks, and collect accumulated content.

## Quick Start

```rust
use praisonai::streaming::{StreamEvent, StreamEventType, StreamCollector};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut collector = StreamCollector::new();
    
    // Process streaming events
    collector.process(StreamEvent::request_start());
    collector.process(StreamEvent::first_token("Hello"));
    collector.process(StreamEvent::delta_text(" "));
    collector.process(StreamEvent::delta_text("World"));
    collector.process(StreamEvent::stream_end());
    
    println!("Content: {}", collector.get_content()); // "Hello World"
    println!("TTFT: {}ms", collector.metrics.ttft_ms());
    
    Ok(())
}
```

## StreamEventType

Event types during streaming:

| Event | Description |
|-------|-------------|
| `RequestStart` | Before API call is made |
| `HeadersReceived` | HTTP headers arrived |
| `FirstToken` | First content delta (TTFT marker) |
| `DeltaText` | Text content delta |
| `DeltaToolCall` | Tool call delta |
| `ToolCallEnd` | Tool call complete |
| `LastToken` | Final content delta |
| `StreamEnd` | Stream completed successfully |
| `Error` | Error during streaming |

## StreamEvent

Create and handle streaming events:

```rust
use praisonai::streaming::{StreamEvent, StreamEventType, ToolCallData};

// Create basic event
let event = StreamEvent::new(StreamEventType::DeltaText)
    .content("Hello")
    .agent_id("agent-1")
    .session_id("session-123")
    .run_id("run-456")
    .metadata("model", "gpt-4");

// Helper constructors
let start = StreamEvent::request_start();
let first = StreamEvent::first_token("H");
let delta = StreamEvent::delta_text("ello");
let end = StreamEvent::stream_end();
let error = StreamEvent::error_event("Connection failed");

// Tool call event
let tool_event = StreamEvent::new(StreamEventType::DeltaToolCall)
    .tool_call(ToolCallData::new("search")
        .arguments(r#"{"query": "rust"}"#)
        .id("call-123"));

// Reasoning/thinking content
let reasoning = StreamEvent::delta_text("Let me think...")
    .reasoning(true);
```

### StreamEvent Fields

| Field | Type | Description |
|-------|------|-------------|
| `event_type` | `StreamEventType` | Type of event |
| `timestamp` | `u64` | Milliseconds since epoch |
| `content` | `Option<String>` | Text content |
| `tool_call` | `Option<ToolCallData>` | Tool call data |
| `error` | `Option<String>` | Error message |
| `is_reasoning` | `bool` | Whether content is reasoning |
| `agent_id` | `Option<String>` | Agent identifier |
| `session_id` | `Option<String>` | Session identifier |
| `run_id` | `Option<String>` | Run identifier |
| `metadata` | `HashMap<String, String>` | Additional data |

## StreamMetrics

Track timing metrics:

```rust
use praisonai::streaming::{StreamMetrics, StreamEvent, StreamEventType};

let mut metrics = StreamMetrics::new();

// Update from events
metrics.update_from_event(&StreamEvent::request_start());
metrics.update_from_event(&StreamEvent::first_token("H"));
for _ in 0..50 {
    metrics.update_from_event(&StreamEvent::delta_text("x"));
}
metrics.update_from_event(&StreamEvent::new(StreamEventType::LastToken));
metrics.update_from_event(&StreamEvent::stream_end());

// Get metrics
println!("TTFT: {}ms", metrics.ttft_ms());
println!("Duration: {}ms", metrics.stream_duration_ms());
println!("Total: {}ms", metrics.total_time_ms());
println!("Tokens/sec: {:.1}", metrics.tokens_per_second());
println!("Token count: {}", metrics.token_count);
```

### Manual Marking

```rust
let mut metrics = StreamMetrics::new();

metrics.mark_request_start();
// ... HTTP request ...
metrics.mark_first_token();
// ... process tokens ...
metrics.increment_tokens();
metrics.increment_tokens();
metrics.mark_last_token();
metrics.mark_stream_end();
```

### Metric Methods

| Method | Description |
|--------|-------------|
| `ttft_ms()` | Time to first token (ms) |
| `stream_duration_ms()` | First to last token (ms) |
| `total_time_ms()` | Request to stream end (ms) |
| `tokens_per_second()` | Throughput |

## StreamCallback

Handle events with callbacks:

```rust
use praisonai::streaming::{StreamCallback, StreamEvent};
use std::sync::atomic::{AtomicUsize, Ordering};

struct PrintCallback;

impl StreamCallback for PrintCallback {
    fn on_event(&self, event: &StreamEvent) {
        if let Some(content) = &event.content {
            print!("{}", content);  // Print tokens as they arrive
        }
    }
}

struct MetricCallback {
    token_count: AtomicUsize,
}

impl StreamCallback for MetricCallback {
    fn on_event(&self, event: &StreamEvent) {
        match event.event_type {
            StreamEventType::DeltaText => {
                self.token_count.fetch_add(1, Ordering::SeqCst);
            }
            StreamEventType::StreamEnd => {
                println!("\nTokens: {}", self.token_count.load(Ordering::SeqCst));
            }
            _ => {}
        }
    }
}
```

### Async Callbacks

```rust
use praisonai::streaming::{AsyncStreamCallback, StreamEvent};
use async_trait::async_trait;

struct AsyncLogger;

#[async_trait]
impl AsyncStreamCallback for AsyncLogger {
    async fn on_event(&self, event: &StreamEvent) {
        // Async logging, database writes, etc.
        log_event(event).await;
    }
}
```

## StreamHandler

Manage multiple callbacks:

```rust
use praisonai::streaming::{StreamHandler, StreamEvent, StreamCallback};

let mut handler = StreamHandler::new();

handler.add_callback(PrintCallback);
handler.add_callback(MetricCallback { 
    token_count: AtomicUsize::new(0) 
});

println!("Callbacks: {}", handler.callback_count());

// Emit events to all callbacks
handler.emit(&StreamEvent::request_start());
handler.emit(&StreamEvent::delta_text("Hello"));
handler.emit(&StreamEvent::stream_end());
```

## StreamCollector

Collect events and accumulate content:

```rust
use praisonai::streaming::{StreamCollector, StreamEvent};

let mut collector = StreamCollector::new();

// Process events
collector.process(StreamEvent::request_start());
collector.process(StreamEvent::first_token("Hello"));
collector.process(StreamEvent::delta_text(" "));
collector.process(StreamEvent::delta_text("World!"));
collector.process(StreamEvent::stream_end());

// Get results
println!("Content: {}", collector.get_content());     // "Hello World!"
println!("Events: {}", collector.event_count());      // 5
println!("Complete: {}", collector.is_complete());    // true
println!("Has error: {}", collector.has_error());     // false

// Access metrics
println!("TTFT: {}ms", collector.metrics.ttft_ms());
println!("Tokens: {}", collector.metrics.token_count);
```

### Error Handling

```rust
let mut collector = StreamCollector::new();

collector.process(StreamEvent::request_start());
collector.process(StreamEvent::error_event("API rate limit exceeded"));

if collector.has_error() {
    println!("Error: {}", collector.get_error().unwrap());
}
assert!(!collector.is_complete());
```

## ToolCallData

Streaming tool call information:

```rust
use praisonai::streaming::ToolCallData;

let tool_call = ToolCallData::new("search")
    .arguments(r#"{"query": "rust programming"}"#)
    .id("call-abc123");

println!("Tool: {}", tool_call.name);
println!("Args: {}", tool_call.arguments);
println!("ID: {:?}", tool_call.id);
```

## Example: Streaming Chat

```rust
use praisonai::streaming::{StreamCollector, StreamEvent, StreamMetrics};

async fn stream_response(prompt: &str) {
    let mut collector = StreamCollector::new();
    
    // Simulate streaming response
    collector.process(StreamEvent::request_start());
    
    // Print tokens as they arrive
    let tokens = ["Hello", " ", "from", " ", "streaming", "!"];
    for (i, token) in tokens.iter().enumerate() {
        let event = if i == 0 {
            StreamEvent::first_token(*token)
        } else {
            StreamEvent::delta_text(*token)
        };
        
        print!("{}", token);  // Real-time output
        collector.process(event);
        
        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    }
    
    collector.process(StreamEvent::stream_end());
    
    println!("\n\nMetrics:");
    println!("  TTFT: {}ms", collector.metrics.ttft_ms());
    println!("  Total: {}ms", collector.metrics.total_time_ms());
    println!("  Tokens: {}", collector.metrics.token_count);
}
```

## Related

<CardGroup cols={2}>
  <Card title="LLM" icon="microchip" href="/docs/rust/llm">
    LLM providers and configuration
  </Card>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Streaming agent responses
  </Card>
  <Card title="Callbacks" icon="bell" href="/docs/rust/callbacks">
    Event callbacks
  </Card>
  <Card title="Async" icon="arrows-rotate" href="/docs/rust/async">
    Async patterns
  </Card>
</CardGroup>
