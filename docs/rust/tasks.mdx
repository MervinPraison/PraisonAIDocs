---
title: "Tasks"
sidebarTitle: "Tasks"
description: "Task definition and execution in the PraisonAI Rust SDK"
icon: "list-check"
---

# Tasks

The Tasks module provides task-based workflow organization with dependencies, callbacks, and structured outputs.

## Quick Start

```rust
use praisonai::task::{Task, TaskOutput, TaskStatus};

// Create a task
let task = Task::new("Research AI trends for 2024")
    .name("research")
    .expected_output("A summary of top AI trends")
    .build()?;

println!("Task ID: {}", task.id());
println!("Description: {}", task.description);
```

## TaskOutput

Result of task execution:

```rust
use praisonai::task::TaskOutput;

let output = TaskOutput::new("Here is the research summary...", "task-123")
    .with_agent("researcher")
    .with_duration(5000)  // 5 seconds
    .with_tokens(1500)
    .with_metadata("sources", serde_json::json!(["source1", "source2"]));

println!("Raw: {}", output.as_str());
println!("Agent: {:?}", output.agent_name);
println!("Duration: {:?}", output.duration_ms);
println!("Tokens: {:?}", output.tokens_used);

// Parse as JSON if applicable
if let Ok(json) = output.parse_json() {
    println!("JSON: {}", json);
}
```

### TaskOutput Fields

| Field | Type | Description |
|-------|------|-------------|
| `raw` | String | Raw output text |
| `task_id` | String | Associated task ID |
| `json_output` | Option | Parsed JSON if available |
| `agent_name` | Option | Agent that produced output |
| `duration_ms` | Option | Execution time in ms |
| `tokens_used` | Option | Tokens consumed |
| `metadata` | HashMap | Additional data |

## TaskStatus

Current state of a task:

| Status | Description |
|--------|-------------|
| `NotStarted` | Task hasn't begun |
| `InProgress` | Currently executing |
| `Completed` | Successfully finished |
| `Failed` | Execution failed |
| `Skipped` | Intentionally skipped |

```rust
use praisonai::task::TaskStatus;

let status = TaskStatus::InProgress;
match status {
    TaskStatus::NotStarted => println!("Not started"),
    TaskStatus::InProgress => println!("Running..."),
    TaskStatus::Completed => println!("Done!"),
    TaskStatus::Failed => println!("Failed"),
    TaskStatus::Skipped => println!("Skipped"),
}
```

## OnError

Error handling behavior:

| Behavior | Description |
|----------|-------------|
| `Stop` | Stop workflow on error |
| `Continue` | Continue to next task |
| `Retry` | Retry the task |

## Task

A unit of work for agents:

```rust
use praisonai::task::{Task, OnError};

let task = Task::new("Analyze sales data")
    .name("analysis")
    .expected_output("Sales insights report")
    .agent("analyst")
    .context(vec!["research_task"])  // Dependencies
    .max_retries(3)
    .on_error(OnError::Retry)
    .tools(vec!["calculator", "chart_generator"])
    .build()?;

// Query task
println!("ID: {}", task.id());
println!("Name: {}", task.display_name());
println!("Completed: {}", task.is_completed());
println!("Failed: {}", task.is_failed());
println!("Can retry: {}", task.can_retry());
```

### TaskBuilder

Build tasks with fluent API:

```rust
use praisonai::task::Task;

let task = Task::new("Primary task description")
    .name("task-name")                           // Optional name
    .expected_output("What output should look like")
    .agent("agent-name")                         // Assigned agent
    .context(vec!["dep1", "dep2"])               // Dependencies
    .tools(vec!["tool1", "tool2"])               // Available tools
    .max_retries(2)                              // Retry count
    .async_execution(true)                       // Run async
    .markdown(true)                              // Format as markdown
    .output_file("output.txt")                   // Save to file
    .output_json(schema)                         // JSON structure
    .build()?;
```

### Task Methods

| Method | Description |
|--------|-------------|
| `id()` | Get task ID |
| `display_name()` | Get name or description |
| `is_completed()` | Check if completed |
| `is_failed()` | Check if failed |
| `can_retry()` | Check if retries available |
| `increment_retry()` | Increment retry counter |
| `set_result(output)` | Set task output |
| `set_failed(error)` | Mark as failed |
| `result_str()` | Get result as string |
| `substitute_variables(ctx)` | Replace variables |
| `to_dict()` | Convert to JSON |

## TaskConfig

Configuration options:

```rust
use praisonai::task::TaskConfig;

let config = TaskConfig::default();

println!("Max retries: {}", config.max_retries);
println!("Timeout: {:?}", config.timeout_seconds);
println!("Async: {}", config.async_execution);
println!("Markdown: {}", config.markdown_output);
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `max_retries` | usize | 0 | Max retry attempts |
| `timeout_seconds` | Option | None | Execution timeout |
| `async_execution` | bool | false | Run asynchronously |
| `markdown_output` | bool | false | Format as markdown |
| `output_file` | Option | None | Save output to file |

## Example: Multi-Task Workflow

```rust
use praisonai::task::{Task, TaskOutput, TaskStatus};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Define tasks
    let research = Task::new("Research market trends")
        .name("research")
        .expected_output("Market analysis")
        .agent("researcher")
        .build()?;
    
    let analysis = Task::new("Analyze research findings")
        .name("analysis")
        .expected_output("Key insights")
        .agent("analyst")
        .context(vec!["research"])  // Depends on research
        .build()?;
    
    let report = Task::new("Write final report")
        .name("report")
        .expected_output("Executive summary")
        .agent("writer")
        .context(vec!["analysis"])  // Depends on analysis
        .output_file("report.md")
        .markdown(true)
        .build()?;
    
    // Execute in order
    let tasks = vec![research, analysis, report];
    
    for mut task in tasks {
        println!("Executing: {}", task.display_name());
        
        // Simulate execution
        let output = TaskOutput::new(
            format!("Output for {}", task.display_name()),
            task.id()
        );
        
        task.set_result(output);
        assert!(task.is_completed());
        
        if let Some(result) = task.result_str() {
            println!("Result: {}", result);
        }
    }
    
    Ok(())
}
```

## Example: Task with Variable Substitution

```rust
use praisonai::task::Task;
use std::collections::HashMap;

let task = Task::new("Analyze data for {{company}} in {{year}}")
    .name("analysis")
    .build()?;

let mut context = HashMap::new();
context.insert("company".to_string(), "Acme Corp".to_string());
context.insert("year".to_string(), "2024".to_string());

let description = task.substitute_variables(&context);
println!("{}", description);  // "Analyze data for Acme Corp in 2024"
```

## Related

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Agent API
  </Card>
  <Card title="Agent Team" icon="people-group" href="/docs/rust/agent-team">
    Multi-agent coordination
  </Card>
  <Card title="Agent Flow" icon="diagram-project" href="/docs/rust/agent-flow">
    Workflow patterns
  </Card>
  <Card title="Planning" icon="clipboard-list" href="/docs/rust/planning">
    Plan mode
  </Card>
</CardGroup>
