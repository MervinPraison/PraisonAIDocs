---
title: "Plugins"
sidebarTitle: "Plugins"
description: "Dynamic plugin system for extending PraisonAI Rust SDK"
icon: "puzzle-piece"
---

# Plugins

The Plugins module provides a hook-based extension system for dynamically extending agent behavior.

## Quick Start

```rust
use praisonai::plugins::{Plugin, PluginHook, PluginInfo, PluginManager, FunctionPlugin};

// Create a function plugin
let logger = FunctionPlugin::new(
    "logger",
    vec![PluginHook::BeforeAgent, PluginHook::AfterAgent],
    |hook, data| {
        println!("[{:?}] {}", hook, data);
        Ok(None)
    }
);

// Register with manager
let mut manager = PluginManager::new();
manager.register(Box::new(logger));

// Execute hooks
manager.execute(PluginHook::BeforeAgent, serde_json::json!({"agent": "test"}))?;
```

## PluginHook

Available hook points in the agent lifecycle:

| Hook | Description |
|------|-------------|
| `BeforeAgent` | Before agent starts processing |
| `AfterAgent` | After agent completes |
| `BeforeTool` | Before tool execution |
| `AfterTool` | After tool execution |
| `BeforeLlm` | Before LLM call |
| `AfterLlm` | After LLM response |
| `BeforeMemory` | Before memory operation |
| `AfterMemory` | After memory operation |
| `OnError` | When an error occurs |
| `OnWorkflowStart` | Workflow begins |
| `OnWorkflowEnd` | Workflow completes |
| `OnHandoff` | Agent-to-agent handoff |

```rust
use praisonai::plugins::PluginHook;

// Get all hooks
let all_hooks = PluginHook::all();
println!("Available hooks: {:?}", all_hooks);
```

## PluginType

Categories of plugins:

| Type | Description |
|------|-------------|
| `Hook` | Lifecycle hooks |
| `Tool` | Tool providers |
| `Guardrail` | Validation plugins |
| `Llm` | LLM providers |
| `Memory` | Memory adapters |
| `Custom` | Custom plugins |

## PluginInfo

Metadata about a plugin:

```rust
use praisonai::plugins::{PluginInfo, PluginType, PluginHook};

let info = PluginInfo::new("my-plugin")
    .version("1.0.0")
    .description("A custom plugin")
    .plugin_type(PluginType::Hook)
    .hook(PluginHook::BeforeAgent)
    .hook(PluginHook::AfterAgent);

println!("Name: {}", info.name);
println!("Version: {:?}", info.version);
println!("Hooks: {:?}", info.hooks);
```

## Plugin Trait

Implement custom plugins:

```rust
use praisonai::plugins::{Plugin, PluginHook, PluginInfo, PluginType};
use praisonai::error::Result;

struct MetricsPlugin {
    call_count: std::sync::atomic::AtomicUsize,
}

impl Plugin for MetricsPlugin {
    fn info(&self) -> PluginInfo {
        PluginInfo::new("metrics")
            .version("1.0.0")
            .plugin_type(PluginType::Hook)
            .hooks(vec![PluginHook::BeforeAgent, PluginHook::AfterAgent])
    }
    
    fn name(&self) -> &str {
        "metrics"
    }
    
    fn init(&mut self) -> Result<()> {
        println!("Metrics plugin initialized");
        Ok(())
    }
    
    fn shutdown(&mut self) -> Result<()> {
        println!("Metrics plugin shutdown");
        Ok(())
    }
    
    fn execute(
        &self,
        hook: PluginHook,
        data: serde_json::Value,
    ) -> Result<Option<serde_json::Value>> {
        use std::sync::atomic::Ordering;
        
        match hook {
            PluginHook::BeforeAgent => {
                self.call_count.fetch_add(1, Ordering::SeqCst);
                println!("Agent starting (call #{})", 
                    self.call_count.load(Ordering::SeqCst));
            }
            PluginHook::AfterAgent => {
                println!("Agent completed");
            }
            _ => {}
        }
        
        Ok(None)
    }
    
    fn handles(&self, hook: PluginHook) -> bool {
        matches!(hook, PluginHook::BeforeAgent | PluginHook::AfterAgent)
    }
}
```

## FunctionPlugin

Simple function-based plugins:

```rust
use praisonai::plugins::{FunctionPlugin, PluginHook};

// Logging plugin
let logger = FunctionPlugin::new(
    "logger",
    vec![PluginHook::BeforeAgent, PluginHook::AfterAgent, PluginHook::OnError],
    |hook, data| {
        let timestamp = chrono::Utc::now();
        println!("[{}] {:?}: {}", timestamp.format("%H:%M:%S"), hook, data);
        Ok(None)
    }
);

// Transform plugin (modifies data)
let transformer = FunctionPlugin::new(
    "transformer",
    vec![PluginHook::BeforeAgent],
    |_hook, mut data| {
        // Add metadata
        if let Some(obj) = data.as_object_mut() {
            obj.insert("processed".to_string(), serde_json::json!(true));
        }
        Ok(Some(data))
    }
);
```

## PluginManager

Manage and execute plugins:

```rust
use praisonai::plugins::{PluginManager, FunctionPlugin, PluginHook};

let mut manager = PluginManager::new();

// Register plugins
let plugin1 = FunctionPlugin::new("p1", vec![PluginHook::BeforeAgent], |_, _| Ok(None));
let plugin2 = FunctionPlugin::new("p2", vec![PluginHook::AfterAgent], |_, _| Ok(None));

manager.register(Box::new(plugin1));
manager.register(Box::new(plugin2));

// Initialize all
manager.init_all()?;

// Execute hooks
let data = serde_json::json!({"input": "Hello"});
let result = manager.execute(PluginHook::BeforeAgent, data)?;

// Get plugins by hook
let before_plugins = manager.plugins_for_hook(PluginHook::BeforeAgent);
println!("Before agent plugins: {}", before_plugins.len());

// List all plugins
for name in manager.plugin_names() {
    println!("Plugin: {}", name);
}

// Unregister
manager.unregister("p1");

// Shutdown all
manager.shutdown_all()?;
```

### Execute with Chain

Plugins can modify data in a chain:

```rust
use praisonai::plugins::{PluginManager, FunctionPlugin, PluginHook};

let mut manager = PluginManager::new();

// Each plugin can transform the data
manager.register(Box::new(FunctionPlugin::new(
    "add-timestamp",
    vec![PluginHook::BeforeAgent],
    |_, mut data| {
        if let Some(obj) = data.as_object_mut() {
            obj.insert("timestamp".to_string(), serde_json::json!(chrono::Utc::now().to_rfc3339()));
        }
        Ok(Some(data))
    }
)));

manager.register(Box::new(FunctionPlugin::new(
    "add-version",
    vec![PluginHook::BeforeAgent],
    |_, mut data| {
        if let Some(obj) = data.as_object_mut() {
            obj.insert("version".to_string(), serde_json::json!("1.0"));
        }
        Ok(Some(data))
    }
)));

// Execute - data flows through all plugins
let input = serde_json::json!({"message": "Hello"});
let output = manager.execute(PluginHook::BeforeAgent, input)?;
// output now contains: {message, timestamp, version}
```

## Example: Audit Plugin

```rust
use praisonai::plugins::{Plugin, PluginHook, PluginInfo, PluginType};
use praisonai::error::Result;
use std::sync::{Arc, RwLock};

struct AuditPlugin {
    log: Arc<RwLock<Vec<String>>>,
}

impl AuditPlugin {
    fn new() -> Self {
        Self {
            log: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    fn get_log(&self) -> Vec<String> {
        self.log.read().unwrap().clone()
    }
}

impl Plugin for AuditPlugin {
    fn info(&self) -> PluginInfo {
        PluginInfo::new("audit")
            .version("1.0.0")
            .plugin_type(PluginType::Hook)
            .hooks(PluginHook::all())
    }
    
    fn name(&self) -> &str { "audit" }
    fn init(&mut self) -> Result<()> { Ok(()) }
    fn shutdown(&mut self) -> Result<()> { Ok(()) }
    
    fn execute(
        &self,
        hook: PluginHook,
        data: serde_json::Value,
    ) -> Result<Option<serde_json::Value>> {
        let entry = format!(
            "[{}] {:?}: {}",
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S"),
            hook,
            data.to_string().chars().take(100).collect::<String>()
        );
        
        self.log.write().unwrap().push(entry);
        Ok(None)
    }
    
    fn handles(&self, _hook: PluginHook) -> bool {
        true  // Handle all hooks
    }
}
```

## Related

<CardGroup cols={2}>
  <Card title="Hooks" icon="webhook" href="/docs/rust/hooks">
    Event hooks
  </Card>
  <Card title="Guardrails" icon="shield-halved" href="/docs/rust/guardrails">
    Input/output validation
  </Card>
  <Card title="Agent" icon="robot" href="/docs/rust/agent">
    Agent API
  </Card>
  <Card title="Tools" icon="wrench" href="/docs/rust/tools">
    Tool system
  </Card>
</CardGroup>
