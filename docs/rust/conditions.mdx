---
title: "Conditions"
sidebarTitle: "Conditions"
description: "Workflow routing conditions in the PraisonAI Rust SDK"
icon: "code-branch"
---

# Conditions

The Conditions module provides protocols and implementations for workflow routing, enabling conditional execution in agent workflows.

## Quick Start

```rust
use praisonai::conditions::{ExpressionCondition, DictCondition, ConditionProtocol};

// Expression-based condition
let condition = ExpressionCondition::new("score > 80");

let context = [("score".to_string(), serde_json::json!(85))]
    .into_iter().collect();
    
if condition.evaluate(&context) {
    println!("Condition met!");
}
```

## ConditionProtocol

Interface for condition implementations:

```rust
use praisonai::conditions::ConditionProtocol;

pub trait ConditionProtocol {
    fn evaluate(&self, context: &HashMap<String, Value>) -> bool;
}
```

## RoutingConditionProtocol

Extended protocol for routing:

```rust
use praisonai::conditions::RoutingConditionProtocol;

pub trait RoutingConditionProtocol: ConditionProtocol {
    fn get_target(&self, context: &HashMap<String, Value>) -> Vec<String>;
}
```

## ExpressionCondition

Simple expression-based conditions:

```rust
use praisonai::conditions::ExpressionCondition;
use std::collections::HashMap;

// Numeric comparison
let condition = ExpressionCondition::new("score > 80");
let mut context = HashMap::new();
context.insert("score".to_string(), serde_json::json!(85));
println!("Passed: {}", condition.evaluate(&context));  // true

// String comparison
let status_check = ExpressionCondition::new("status == 'approved'");
context.insert("status".to_string(), serde_json::json!("approved"));
println!("Approved: {}", status_check.evaluate(&context));  // true

// Operators: >, <, >=, <=, ==, !=
let less_than = ExpressionCondition::new("count < 10");
let not_equal = ExpressionCondition::new("state != 'error'");
```

### Supported Operators

| Operator | Description |
|----------|-------------|
| `>` | Greater than |
| `<` | Less than |
| `>=` | Greater or equal |
| `<=` | Less or equal |
| `==` | Equal |
| `!=` | Not equal |

## DictCondition

Dictionary-based routing:

```rust
use praisonai::conditions::DictCondition;

let condition = DictCondition::new("status")
    .when("approved", vec!["process_approval".into()])
    .when("rejected", vec!["handle_rejection".into()])
    .when("pending", vec!["wait_agent".into(), "notify_user".into()])
    .default_targets(vec!["error_handler".into()]);

let mut context = HashMap::new();
context.insert("status".to_string(), serde_json::json!("approved"));

// Check evaluation
println!("Matches: {}", condition.evaluate(&context));  // true

// Get routing targets
let targets = condition.get_target(&context);
println!("Route to: {:?}", targets);  // ["process_approval"]
```

### Routing Examples

```rust
// Multi-value routing
let priority = DictCondition::new("priority")
    .when("high", vec!["urgent_handler".into()])
    .when("medium", vec!["normal_handler".into()])
    .when("low", vec!["batch_processor".into()])
    .default_targets(vec!["default_handler".into()]);

// Multiple targets for one value
let notification = DictCondition::new("type")
    .when("critical", vec![
        "email_service".into(), 
        "sms_service".into(), 
        "push_service".into()
    ]);
```

## ClosureCondition

Custom logic with closures:

```rust
use praisonai::conditions::ClosureCondition;

// Simple closure
let custom = ClosureCondition::new(|context| {
    let score = context.get("score")
        .and_then(|v| v.as_i64())
        .unwrap_or(0);
    let attempts = context.get("attempts")
        .and_then(|v| v.as_i64())
        .unwrap_or(0);
    
    score > 50 && attempts < 3
});

// Complex validation
let validator = ClosureCondition::new(|ctx| {
    let has_permission = ctx.get("has_permission")
        .and_then(|v| v.as_bool())
        .unwrap_or(false);
    let role = ctx.get("role")
        .and_then(|v| v.as_str())
        .unwrap_or("");
    
    has_permission || role == "admin"
});
```

## CompositeCondition

Combine multiple conditions:

```rust
use praisonai::conditions::{CompositeCondition, ExpressionCondition, LogicOperator};

// AND: all must match
let and_condition = CompositeCondition::and(vec![
    Box::new(ExpressionCondition::new("score > 80")),
    Box::new(ExpressionCondition::new("verified == true")),
]);

// OR: any must match
let or_condition = CompositeCondition::or(vec![
    Box::new(ExpressionCondition::new("role == 'admin'")),
    Box::new(ExpressionCondition::new("role == 'moderator'")),
]);

// NOT: invert
let not_condition = CompositeCondition::not(
    Box::new(ExpressionCondition::new("banned == true"))
);
```

## Example: Workflow Routing

```rust
use praisonai::workflows::{AgentFlow, Route};
use praisonai::conditions::{DictCondition, ExpressionCondition};
use praisonai::Agent;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create agents
    let classifier = Agent::new()
        .name("classifier")
        .instructions("Classify the request as 'support', 'sales', or 'technical'")
        .build()?;
    
    let support = Agent::new().name("support").build()?;
    let sales = Agent::new().name("sales").build()?;
    let technical = Agent::new().name("technical").build()?;
    
    // Create flow with routing
    let flow = AgentFlow::new()
        .start_with(classifier)
        .then(Route::conditional(
            DictCondition::new("category")
                .when("support", vec!["support".into()])
                .when("sales", vec!["sales".into()])
                .when("technical", vec!["technical".into()])
        ))
        .add_agent(support)
        .add_agent(sales)
        .add_agent(technical)
        .build();
    
    // Run with input
    let result = flow.run("I need help with billing").await?;
    println!("{}", result);
    
    Ok(())
}
```

## Related

<CardGroup cols={2}>
  <Card title="Agent Flow" icon="diagram-project" href="/docs/rust/agent-flow">
    Flow patterns
  </Card>
  <Card title="Workflows" icon="sitemap" href="/docs/rust/workflows">
    Multi-agent workflows
  </Card>
  <Card title="Routing" icon="route" href="/docs/rust/routing">
    Workflow routing
  </Card>
  <Card title="Tasks" icon="list-check" href="/docs/rust/tasks">
    Task management
  </Card>
</CardGroup>
